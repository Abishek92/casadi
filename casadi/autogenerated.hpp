/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef AUTOGENERATED_HPP
#define AUTOGENERATED_HPP
#include <vector>
namespace CasADi{
/// Helper function for 'MayerInput'
/// Input arguments of a Mayer Term \n
/// nx: Number of states: from ffcn.input(INTEGRATOR_X0).size() \n
/// np: Number of parameters: from option number_of_parameters\n
/// 
/// \copydoc scheme_MayerInput
template<class M>
std::vector<M> mayerIn(const M& x=M(),const M& p=M()){
  M ret[2] = {x,p};
  return std::vector<M>(ret,ret+2);
}
/// Helper function for 'OCPInput'
/// Input arguments of an OCP Solver \n
/// ns: Number of shooting nodes: from option number_of_grid_points\n
/// nx: Number of states: from ffcn.input(INTEGRATOR_X0).size() \n
/// nc: Number of constants duting intergation: ffcn.input(INTEGRATOR_P).size()
/// nu: Number of controls: from nc - np \n
/// np: Number of parameters: from option number_of_parameters\n
/// nh: Number of point constraints: from cfcn.input(0).size()
/// 
/// \copydoc scheme_OCPInput
template<class M>
std::vector<M> ocpIn(const M& t=M(),const M& lbx=M(),const M& ubx=M(),const M& x_init=M(),const M& lbxp=M(),const M& ubxp=M(),const M& xp_init=M(),const M& lbu=M(),const M& ubu=M(),const M& u_init=M(),const M& lbp=M(),const M& ubp=M(),const M& p_init=M(),const M& lbh=M(),const M& ubh=M(),const M& lbg=M(),const M& ubg=M()){
  M ret[17] = {t,lbx,ubx,x_init,lbxp,ubxp,xp_init,lbu,ubu,u_init,lbp,ubp,p_init,lbh,ubh,lbg,ubg};
  return std::vector<M>(ret,ret+17);
}
/// Helper function for 'OCPOutput'
/// Output arguments of an OCP Solver
/// 
/// \copydoc scheme_OCPOutput
template<class M>
std::vector<M> ocpOut(const M& x_opt=M(),const M& u_opt=M(),const M& xp_opt=M(),const M& p_opt=M()){
  M ret[4] = {x_opt,u_opt,xp_opt,p_opt};
  return std::vector<M>(ret,ret+4);
}
/// Helper function for 'QPInput'
/// Input arguments of a QP problem
/// 
/// \copydoc scheme_QPInput
template<class M>
std::vector<M> qpIn(const M& h=M(),const M& g=M(),const M& a=M(),const M& lba=M(),const M& uba=M(),const M& lbx=M(),const M& ubx=M(),const M& x_init=M(),const M& lambda_init=M()){
  M ret[9] = {h,g,a,lba,uba,lbx,ubx,x_init,lambda_init};
  return std::vector<M>(ret,ret+9);
}
/// Helper function for 'QPOutput'
/// Output arguments of an QP Solver
/// 
/// \copydoc scheme_QPOutput
template<class M>
std::vector<M> qpOut(const M& primal=M(),const M& cost=M(),const M& lambda_a=M(),const M& lambda_x=M()){
  M ret[4] = {primal,cost,lambda_a,lambda_x};
  return std::vector<M>(ret,ret+4);
}
/// Helper function for 'ControlledDAEInput'
/// Input arguments of an ODE/DAE function
/// 
/// \copydoc scheme_ControlledDAEInput
template<class M>
std::vector<M> controldaeIn(const M& t=M(),const M& x=M(),const M& z=M(),const M& p=M(),const M& u=M(),const M& u_interp=M(),const M& xdot=M(),const M& x_major=M(),const M& t0=M(),const M& tf=M()){
  M ret[10] = {t,x,z,p,u,u_interp,xdot,x_major,t0,tf};
  return std::vector<M>(ret,ret+10);
}
/// Helper function for 'ControlSimulatorInput'
/// Input arguments of a control simulator
/// 
/// \copydoc scheme_ControlSimulatorInput
template<class M>
std::vector<M> controlsimulatorIn(const M& x0=M(),const M& p=M(),const M& u=M()){
  M ret[3] = {x0,p,u};
  return std::vector<M>(ret,ret+3);
}
/// Helper function for 'NLPInput'
/// Input arguments of an NLP Solver
/// 
/// \copydoc scheme_NLPInput
template<class M>
std::vector<M> nlpsolverIn(const M& x_init=M(),const M& lbx=M(),const M& ubx=M(),const M& lbg=M(),const M& ubg=M(),const M& lambda_init=M(),const M& p=M()){
  M ret[7] = {x_init,lbx,ubx,lbg,ubg,lambda_init,p};
  return std::vector<M>(ret,ret+7);
}
/// Helper function for 'NLPOutput'
/// Output arguments of an NLP Solver
/// 
/// \copydoc scheme_NLPOutput
template<class M>
std::vector<M> nlpsolverOut(const M& x_opt=M(),const M& cost=M(),const M& lambda_g=M(),const M& lambda_x=M(),const M& g=M()){
  M ret[5] = {x_opt,cost,lambda_g,lambda_x,g};
  return std::vector<M>(ret,ret+5);
}
/// Helper function for 'DAEInput'
/// Input arguments of an ODE/DAE function
/// 
/// \copydoc scheme_DAEInput
template<class M>
std::vector<M> daeIn(const M& x=M(),const M& z=M(),const M& p=M(),const M& t=M(),const M& xdot=M()){
  M ret[5] = {x,z,p,t,xdot};
  return std::vector<M>(ret,ret+5);
}
/// Helper function for 'DAEOutput'
/// Output arguments of an DAE function
/// 
/// \copydoc scheme_DAEOutput
template<class M>
std::vector<M> daeOut(const M& ode=M(),const M& alg=M(),const M& quad=M()){
  M ret[3] = {ode,alg,quad};
  return std::vector<M>(ret,ret+3);
}
/// Helper function for 'RDAEInput'
/// Input arguments of an ODE/DAE backward integration function
/// 
/// \copydoc scheme_RDAEInput
template<class M>
std::vector<M> rdaeIn(const M& rx=M(),const M& rz=M(),const M& rp=M(),const M& x=M(),const M& z=M(),const M& p=M(),const M& t=M(),const M& rxdot=M()){
  M ret[8] = {rx,rz,rp,x,z,p,t,rxdot};
  return std::vector<M>(ret,ret+8);
}
/// Helper function for 'RDAEOutput'
/// Output arguments of an ODE/DAE backward integration function
/// 
/// \copydoc scheme_RDAEOutput
template<class M>
std::vector<M> rdaeOut(const M& ode=M(),const M& alg=M(),const M& quad=M()){
  M ret[3] = {ode,alg,quad};
  return std::vector<M>(ret,ret+3);
}
/// Helper function for 'IntegratorInput'
/// Input arguments of an integrator
/// 
/// \copydoc scheme_IntegratorInput
template<class M>
std::vector<M> integratorIn(const M& x0=M(),const M& p=M(),const M& rx0=M()){
  M ret[3] = {x0,p,rx0};
  return std::vector<M>(ret,ret+3);
}
/// Helper function for 'IntegratorOutput'
/// Output arguments of an integrator
/// 
/// \copydoc scheme_IntegratorOutput
template<class M>
std::vector<M> integratorOut(const M& xf=M(),const M& qf=M(),const M& rxf=M(),const M& rqf=M()){
  M ret[4] = {xf,qf,rxf,rqf};
  return std::vector<M>(ret,ret+4);
}
}
#endif //AUTOGENERATED_HPP
