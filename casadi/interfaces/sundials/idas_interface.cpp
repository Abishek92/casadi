/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */


#include "idas_interface.hpp"

#include "casadi/core/std_vector_tools.hpp"

#ifdef WITH_SYSTEM_SUNDIALS
#include <external_packages/sundials-2.5mod/idas/idas_spils_impl.h>
#endif

using namespace std;
namespace casadi {

  extern "C"
  int CASADI_INTEGRATOR_IDAS_EXPORT
      casadi_register_integrator_idas(Integrator::Plugin* plugin) {
    plugin->creator = IdasInterface::creator;
    plugin->name = "idas";
    plugin->doc = IdasInterface::meta_doc.c_str();
    plugin->version = 30;
    return 0;
  }

  extern "C"
  void CASADI_INTEGRATOR_IDAS_EXPORT casadi_load_integrator_idas() {
    Integrator::registerPlugin(casadi_register_integrator_idas);
  }

  IdasInterface::IdasInterface(const std::string& name, Oracle* dae)
    : SundialsInterface(name, dae) {
  }

  IdasInterface::~IdasInterface() {
    clear_memory();
  }

  Options IdasInterface::options_
  = {{&SundialsInterface::options_},
     {{"suppress_algebraic",
       {OT_BOOL,
        "Suppress algebraic variables in the error testing"}},
      {"calc_ic",
       {OT_BOOL,
        "Use IDACalcIC to get consistent initial conditions."}},
      {"calc_icB",
       {OT_BOOL,
        "Use IDACalcIC to get consistent initial conditions for "
        "backwards system [default: equal to calc_ic]."}},
      {"abstolv",
       {OT_DOUBLEVECTOR,
        "Absolute tolerarance for each component"}},
      {"fsens_abstolv",
       {OT_DOUBLEVECTOR,
        "Absolute tolerarance for each component, forward sensitivities"}},
      {"max_step_size",
       {OT_DOUBLE,
        "Maximim step size"}},
      {"first_time",
       {OT_DOUBLE,
        "First requested time as a fraction of the time interval"}},
      {"cj_scaling",
       {OT_BOOL,
        "IDAS scaling on cj for the user-defined linear solver module"}},
      {"extra_fsens_calc_ic",
       {OT_BOOL,
        "Call calc ic an extra time, with fsens=0"}},
      {"init_xdot",
       {OT_DOUBLEVECTOR,
        "Initial values for the state derivatives"}}
     }
  };

  void IdasInterface::init(const Dict& opts) {
    log("IdasInterface::init", "begin");

    // Call the base class init
    SundialsInterface::init(opts);

    // Default options
    cj_scaling_ = false;
    calc_ic_ = true;
    suppress_algebraic_ = false;
    max_step_size_ = 0;

    // Read options
    for (auto&& op : opts) {
      if (op.first=="init_xdot") {
        init_xdot_ = op.second;
      } else if (op.first=="cj_scaling") {
        cj_scaling_ = op.second;
      } else if (op.first=="calc_ic") {
        calc_ic_ = op.second;
      } else if (op.first=="suppress_algebraic") {
        suppress_algebraic_ = op.second;
      } else if (op.first=="max_step_size") {
        max_step_size_ = op.second;
      } else if (op.first=="abstolv") {
        abstolv_ = op.second;
      } else if (op.first=="fsens_abstolv") {
        fsens_abstolv_ = op.second;
      }
    }

    // Default dependent options
    calc_icB_ = calc_ic_;
    first_time_ = grid_.back();

    // Read dependent options
    for (auto&& op : opts) {
      if (op.first=="calc_icB") {
        calc_icB_ = op.second;
      } else if (op.first=="first_time") {
        first_time_ = op.second;
      }
    }

    // Get initial conditions for the state derivatives
    if (init_xdot_.empty()) {
      init_xdot_.resize(nx_, 0);
    } else {
      casadi_assert_message(
        init_xdot_.size()==nx_,
        "Option \"init_xdot\" has incorrect length. Expecting " << nx_
        << ", but got " << init_xdot_.size()
        << ". Note that this message may actually be generated by the augmented"
        " integrator. In that case, make use of the 'augmented_options' options"
        " to correct 'init_xdot' for the augmented integrator.");
    }

    // Attach functions for jacobian information
    if (exact_jacobian_) {
      switch (linsol_f_) {
      case SD_ITERATIVE:
        casadi_assert(dae_!=0);
        jtimes_ = dae_->create("jtimes",
          {"t", "x", "z", "p", "fwd_x", "fwd_z"}, {"fwd_ode", "fwd_alg"});
        alloc(jtimes_);
        break;
      default: break;
      }
    }

    if (exact_jacobianB_) {
      switch (linsol_g_) {
      case SD_ITERATIVE:
        g_fwd_ = g_.derivative(1, 0);
        alloc(g_fwd_);
        break;
      default: break;
      }
    }

    log("IdasInterface::init", "end");
  }

  void IdasInterface::initTaping(IdasMemory* m) const {
    casadi_assert(!m->isInitTaping);

    // Get the interpolation type
    int interpType;
    if (interpolation_type_=="hermite") {
      interpType = IDA_HERMITE;
    } else if (interpolation_type_=="polynomial") {
      interpType = IDA_POLYNOMIAL;
    } else {
      casadi_error("\"interpolation_type\" must be \"hermite\" or \"polynomial\"");
    }

    // Initialize adjoint sensitivities
    int flag = IDAAdjInit(m->mem, steps_per_checkpoint_, interpType);
    if (flag != IDA_SUCCESS) idas_error("IDAAdjInit", flag);

    m->isInitTaping = true;
  }

  void IdasInterface::initAdj(IdasMemory* m) const {
    log("IdasInterface::initAdj", "start");

    casadi_assert(!m->isInitAdj);
    int flag;

    // Create backward problem
    flag = IDACreateB(m->mem, &m->whichB);
    if (flag != IDA_SUCCESS) idas_error("IDACreateB", flag);

    // Initialize the backward problem
    double tB0 = grid_.back();
    flag = IDAInitB(m->mem, m->whichB, resB_wrapper, tB0, m->rxz, m->rxzdot);
    if (flag != IDA_SUCCESS) idas_error("IDAInitB", flag);

    // Set tolerances
    flag = IDASStolerancesB(m->mem, m->whichB, reltolB_, abstolB_);
    if (flag!=IDA_SUCCESS) idas_error("IDASStolerancesB", flag);

    // User data
    flag = IDASetUserDataB(m->mem, m->whichB, m);
    if (flag != IDA_SUCCESS) idas_error("IDASetUserDataB", flag);

    // Maximum number of steps
    IDASetMaxNumStepsB(m->mem, m->whichB, max_num_steps_);
    if (flag != IDA_SUCCESS) idas_error("IDASetMaxNumStepsB", flag);

    // Set algebraic components
    N_Vector id = N_VNew_Serial(nrx_+nrz_);
    fill_n(NV_DATA_S(id), nrx_, 1);
    fill_n(NV_DATA_S(id)+nrx_, nrz_, 0);

    // Pass this information to IDAS
    flag = IDASetIdB(m->mem, m->whichB, id);
    if (flag != IDA_SUCCESS) idas_error("IDASetIdB", flag);

    // Delete the allocated memory
    N_VDestroy_Serial(id);

    // attach linear solver
    switch (linsol_g_) {
    case SD_DENSE:
      initDenseLinsolB(m);
      break;
    case SD_BANDED:
      initBandedLinsolB(m);
      break;
    case SD_ITERATIVE:
      initIterativeLinsolB(m);
      break;
    case SD_USER_DEFINED:
      initUserDefinedLinsolB(m);
      break;
    default: casadi_error("Uncaught switch");
    }

    // Quadratures for the adjoint problem
    flag = IDAQuadInitB(m->mem, m->whichB, rhsQB_wrapper, m->rq);
    if (flag!=IDA_SUCCESS) idas_error("IDAQuadInitB", flag);

    // Quadrature error control
    if (quad_err_con_) {
      flag = IDASetQuadErrConB(m->mem, m->whichB, true);
      if (flag != IDA_SUCCESS) idas_error("IDASetQuadErrConB", flag);

      flag = IDAQuadSStolerancesB(m->mem, m->whichB, reltolB_, abstolB_);
      if (flag != IDA_SUCCESS) idas_error("IDAQuadSStolerancesB", flag);
    }

    // Mark initialized
    m->isInitAdj = true;

    log("IdasInterface::initAdj", "end");
  }

  void IdasInterface::
  res(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rr) const {
    log("IdasInterface::res", "begin");

    // Get time
    m->time1 = clock();

    // Debug output
    if (monitored("res")) {
      printvar("t", t);
      printvar("xz", xz);
      printvar("xzdot", xzdot);
    }

    // Evaluate f_
    m->arg[DAE_T] = &t;
    m->arg[DAE_X] = NV_DATA_S(xz);
    m->arg[DAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[DAE_P] = get_ptr(m->p);
    m->res[DAE_ODE] = NV_DATA_S(rr);
    m->res[DAE_ALG] = NV_DATA_S(rr)+nx_;
    m->res[DAE_QUAD] = 0;
    f_(m->arg, m->res, m->iw, m->w, 0);

    // Subtract state derivative to get residual
    casadi_axpy(nx_, -1., NV_DATA_S(xzdot), NV_DATA_S(rr));

    // Debug output
    if (monitored("res")) {
      printvar("res", rr);
    }

    // Regularity check
    casadi_assert_message(!regularity_check_ || is_regular(rr),
                          "IdasInterface::res: not regular.");

    m->time2 = clock();
    m->t_res += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::res", "end");
  }

  int IdasInterface::res_wrapper(double t, N_Vector xz, N_Vector xzdot,
                                N_Vector rr, void *user_data) {
    try {
      IdasMemory *m = static_cast<IdasMemory*>(user_data);
      m->self.res(m, t, xz, xzdot, rr);
      return 0;
    } catch(int flag) { // recoverable error
      return flag;
    } catch(exception& e) { // non-recoverable error
      userOut<true, PL_WARN>() << "res failed: " << e.what() << endl;
      return -1;
    }
  }

  void IdasInterface::ehfun_wrapper(int error_code, const char *module, const char *function,
                                   char *msg, void *eh_data) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(eh_data);
      m->self.ehfun(m, error_code, module, function, msg);
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "ehfun failed: " << e.what() << endl;
    }
  }

  void IdasInterface::ehfun(IdasMemory* m, int error_code, const char *module, const char *function,
                            char *msg) const {
    userOut<true, PL_WARN>() << msg << endl;
  }

  void IdasInterface::jtimes(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rr,
                             N_Vector v, N_Vector Jv, double cj,
                             N_Vector tmp1, N_Vector tmp2) const {
    log("IdasInterface::jtimes", "begin");
    // Get time
    m->time1 = clock();

    // Evaluate jtimes_
    m->arg[JTIMES_T] = &t;
    m->arg[JTIMES_X] = NV_DATA_S(xz);
    m->arg[JTIMES_Z] = NV_DATA_S(xz)+nx_;
    m->arg[JTIMES_P] = get_ptr(m->p);
    m->arg[JTIMES_FWD_X] = NV_DATA_S(v);
    m->arg[JTIMES_FWD_Z] = NV_DATA_S(v)+nx_;
    m->res[JTIMES_FWD_ODE] = NV_DATA_S(Jv);
    m->res[JTIMES_FWD_ALG] = NV_DATA_S(Jv) + nx_;
    jtimes_(m->arg, m->res, m->iw, m->w, 0);

    // Subtract state derivative to get residual
    casadi_axpy(nx_, -cj, NV_DATA_S(v), NV_DATA_S(Jv));

    // Log time duration
    m->time2 = clock();
    m->t_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::jtimes", "end");
  }

  int IdasInterface::jtimes_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector rr, N_Vector v,
                                   N_Vector Jv, double cj, void *user_data,
                                   N_Vector tmp1, N_Vector tmp2) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.jtimes(m, t, xz, xzdot, rr, v, Jv, cj, tmp1, tmp2);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "jtimes failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::jtimesB(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector xzB,
                             N_Vector xzdotB, N_Vector resvalB, N_Vector vB,
                             N_Vector JvB, double cjB, N_Vector tmp1B, N_Vector tmp2B) const {
    log("IdasInterface::jtimesB", "begin");
    // Get time
    m->time1 = clock();

    // Debug output
    if (monitored("jtimesB")) {
      printvar("t", t);
      printvar("xz", xz);
      printvar("xzdot", xzdot);
      printvar("xzB", xzB);
      printvar("xzdotB", xzdotB);
      printvar("vB", vB);
    }

    // Hack:
    vector<const double*> arg1(g_fwd_.sz_arg());
    const double** arg1_ = get_ptr(arg1);
    vector<double*> res1(g_fwd_.sz_res());
    double** res1_ = get_ptr(res1);
    vector<int> iw(g_fwd_.sz_iw());
    int* iw_ = get_ptr(iw);
    vector<double> w(g_fwd_.sz_w());
    double* w_ = get_ptr(w);

    // Evaluate g_fwd_
    arg1_[RDAE_T] = &t;
    arg1_[RDAE_X] = NV_DATA_S(xz);
    arg1_[RDAE_Z] = NV_DATA_S(xz)+nx_;
    arg1_[RDAE_P] = get_ptr(m->p);
    arg1_[RDAE_RX] = NV_DATA_S(xzB);
    arg1_[RDAE_RZ] = NV_DATA_S(xzB)+nrx_;
    arg1_[RDAE_RP] = get_ptr(m->rp);
    arg1_[RDAE_NUM_IN + RDAE_T] = 0;
    arg1_[RDAE_NUM_IN + RDAE_X] = 0;
    arg1_[RDAE_NUM_IN + RDAE_Z] = 0;
    arg1_[RDAE_NUM_IN + RDAE_P] = 0;
    arg1_[RDAE_NUM_IN + RDAE_RX] = NV_DATA_S(vB);
    arg1_[RDAE_NUM_IN + RDAE_RZ] = NV_DATA_S(vB)+nrx_;
    arg1_[RDAE_NUM_IN + RDAE_RP] = 0;
    res1_[RDAE_ODE] = 0;
    res1_[RDAE_ALG] = 0;
    res1_[RDAE_QUAD] = 0;
    res1_[RDAE_NUM_OUT + RDAE_ODE] = NV_DATA_S(JvB);
    res1_[RDAE_NUM_OUT + RDAE_ALG] = NV_DATA_S(JvB) + nrx_;
    res1_[RDAE_NUM_OUT + RDAE_QUAD] = 0;
    g_fwd_(arg1_, res1_, iw_, w_, 0);

    // Subtract state derivative to get residual
    casadi_axpy(nrx_, cjB, NV_DATA_S(vB), NV_DATA_S(JvB));

    // Debug output
    if (monitored("jtimesB")) {
      printvar("JvB", JvB);
    }

    // Log time duration
    m->time2 = clock();
    m->t_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::jtimesB", "end");
  }

  int IdasInterface::jtimesB_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector xzB,
                                    N_Vector xzdotB, N_Vector resvalB, N_Vector vB, N_Vector JvB,
                                    double cjB, void *user_data,
                                    N_Vector tmp1B, N_Vector tmp2B) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.jtimesB(m, t, xz, xzdot, xzB, xzdotB, resvalB, vB, JvB, cjB, tmp1B, tmp2B);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "jtimesB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::resS(IdasMemory* m, int Ns, double t, N_Vector xz, N_Vector xzdot,
                          N_Vector resval, N_Vector *xzF, N_Vector* xzdotF, N_Vector *rrF,
                          N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) const {
    log("IdasInterface::resS", "begin");

    // Record the current cpu time
    m->time1 = clock();

    // Commented out since a new implementation currently cannot be tested
    casadi_error("Commented out, #884, #794.");

    // Record timings
    m->time2 = clock();
    m->t_fres += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::resS", "end");
  }

  int IdasInterface::resS_wrapper(int Ns, double t, N_Vector xz, N_Vector xzdot, N_Vector resval,
                                 N_Vector *xzF, N_Vector *xzdotF, N_Vector *rrF, void *user_data,
                                 N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.resS(m, Ns, t, xz, xzdot, resval, xzF, xzdotF, rrF, tmp1, tmp2, tmp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "resS failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::init_memory(void* mem) const {
    SundialsInterface::init_memory(mem);
    auto m = static_cast<IdasMemory*>(mem);

    // Sundials return flag
    int flag;

    // Create IDAS memory block
    m->mem = IDACreate();
    if (m->mem==0) throw CasadiException("IDACreate(): Creation failed");

    // Allocate n-vectors for ivp
    m->xzdot = N_VNew_Serial(nx_+nz_);

    // Initialize Idas
    double t0 = 0;
    N_VConst(0.0, m->xz);
    N_VConst(0.0, m->xzdot);
    IDAInit(m->mem, res_wrapper, t0, m->xz, m->xzdot);
    log("IdasInterface::init", "IDA initialized");

    // Set error handler function
    flag = IDASetErrHandlerFn(m->mem, ehfun_wrapper, &m);
    casadi_assert_message(flag == IDA_SUCCESS, "IDASetErrHandlerFn");

    // Include algebraic variables in error testing
    flag = IDASetSuppressAlg(m->mem, suppress_algebraic_);
    casadi_assert_message(flag == IDA_SUCCESS, "IDASetSuppressAlg");

    // Maxinum order for the multistep method
    flag = IDASetMaxOrd(m->mem, max_multistep_order_);
    casadi_assert_message(flag == IDA_SUCCESS, "IDASetMaxOrd");

    // Set user data
    flag = IDASetUserData(m->mem, m);
    casadi_assert_message(flag == IDA_SUCCESS, "IDASetUserData");

    // Set maximum step size
    flag = IDASetMaxStep(m->mem, max_step_size_);
    casadi_assert_message(flag == IDA_SUCCESS, "IDASetMaxStep");

    if (!abstolv_.empty()) {
      // Vector absolute tolerances
      N_Vector nv_abstol = N_VNew_Serial(abstolv_.size());
      copy(abstolv_.begin(), abstolv_.end(), NV_DATA_S(nv_abstol));
      flag = IDASVtolerances(m->mem, reltol_, nv_abstol);
      casadi_assert_message(flag == IDA_SUCCESS, "IDASVtolerances");
      N_VDestroy_Serial(nv_abstol);
    } else {
      // Scalar absolute tolerances
      flag = IDASStolerances(m->mem, reltol_, abstol_);
      casadi_assert_message(flag == IDA_SUCCESS, "IDASStolerances");
    }

    // Maximum number of steps
    IDASetMaxNumSteps(m->mem, max_num_steps_);
    if (flag != IDA_SUCCESS) idas_error("IDASetMaxNumSteps", flag);

    // Set algebraic components
    N_Vector id = N_VNew_Serial(nx_+nz_);
    fill_n(NV_DATA_S(id), nx_, 1);
    fill_n(NV_DATA_S(id)+nx_, nz_, 0);

    // Pass this information to IDAS
    flag = IDASetId(m->mem, id);
    if (flag != IDA_SUCCESS) idas_error("IDASetId", flag);

    // Delete the allocated memory
    N_VDestroy_Serial(id);

    // attach a linear solver
    switch (linsol_f_) {
    case SD_DENSE:
      initDenseLinsol(m);
      break;
    case SD_BANDED:
      initBandedLinsol(m);
      break;
    case SD_ITERATIVE:
      initIterativeLinsol(m);
      break;
    case SD_USER_DEFINED:
      initUserDefinedLinsol(m);
      break;
    default: casadi_error("Uncaught switch");
    }

    // Quadrature equations
    if (nq_>0) {

      // Initialize quadratures in IDAS
      flag = IDAQuadInit(m->mem, rhsQ_wrapper, m->q);
      if (flag != IDA_SUCCESS) idas_error("IDAQuadInit", flag);

      // Should the quadrature errors be used for step size control?
      if (quad_err_con_) {
        flag = IDASetQuadErrCon(m->mem, true);
        casadi_assert_message(flag == IDA_SUCCESS, "IDASetQuadErrCon");

        // Quadrature error tolerances
        // TODO(Joel): vector absolute tolerances
        flag = IDAQuadSStolerances(m->mem, reltol_, abstol_);
        if (flag != IDA_SUCCESS) idas_error("IDAQuadSStolerances", flag);
      }
    }

    log("IdasInterface::init", "attached linear solver");

    // Adjoint sensitivity problem
    if (!g_.is_null()) {

      // Allocate n-vectors
      m->rxzdot = N_VNew_Serial(nrx_+nrz_);
      N_VConst(0.0, m->rxz);
      N_VConst(0.0, m->rxzdot);
    }
    log("IdasInterface::init", "initialized adjoint sensitivities");

    m->isInitTaping = false;
    m->isInitAdj = false;
  }

  void IdasInterface::reset(IntegratorMemory* mem, double t, const double* _x,
                            const double* _z, const double* _p) const {
    log("IdasInterface::reset", "begin");
    auto m = static_cast<IdasMemory*>(mem);

    // Reset the base classes
    SundialsInterface::reset(mem, t, _x, _z, _p);

    if (nrx_>0 && !m->isInitTaping)
      initTaping(m);

    // Reset timers
    m->t_res = m->t_fres = m->t_jac = m->t_jacB = m->t_lsolve
      = m->t_lsetup_jac = m->t_lsetup_fac = 0;

    // Return flag
    int flag;

    // Re-initialize
    copy(init_xdot_.begin(), init_xdot_.end(), NV_DATA_S(m->xzdot));
    flag = IDAReInit(m->mem, grid_.front(), m->xz, m->xzdot);
    if (flag != IDA_SUCCESS) idas_error("IDAReInit", flag);
    log("IdasInterface::reset", "re-initialized IVP solution");


    // Re-initialize quadratures
    if (nq_>0) {
      flag = IDAQuadReInit(m->mem, m->q);
      if (flag != IDA_SUCCESS) idas_error("IDAQuadReInit", flag);
      log("IdasInterface::reset", "re-initialized quadratures");
    }

    // Turn off sensitivities
    flag = IDASensToggleOff(m->mem);
    if (flag != IDA_SUCCESS) idas_error("IDASensToggleOff", flag);

    // Correct initial conditions, if necessary
    if (calc_ic_) {
      correctInitialConditions(m);
    }

    // Re-initialize backward integration
    if (nrx_>0) {
      flag = IDAAdjReInit(m->mem);
      if (flag != IDA_SUCCESS) idas_error("IDAAdjReInit", flag);
    }

    // Set the stop time of the integration -- don't integrate past this point
    if (stop_at_end_) setStopTime(m, grid_.back());

    log("IdasInterface::reset", "end");
  }


  void IdasInterface::correctInitialConditions(IdasMemory* m) const {
    log("IdasInterface::correctInitialConditions", "begin");

    // Calculate consistent initial conditions
    int flag = IDACalcIC(m->mem, IDA_YA_YDP_INIT , first_time_);
    if (flag != IDA_SUCCESS) idas_error("IDACalcIC", flag);

    // Retrieve the initial values
    flag = IDAGetConsistentIC(m->mem, m->xz, m->xzdot);
    if (flag != IDA_SUCCESS) idas_error("IDAGetConsistentIC", flag);

    // Print progress
    log("IdasInterface::correctInitialConditions", "end");
  }

  void IdasInterface::
  advance(IntegratorMemory* mem, double t, double* x, double* z, double* q) const {
    auto m = static_cast<IdasMemory*>(mem);

    casadi_assert_message(t>=grid_.front(), "IdasInterface::integrate(" << t << "): "
                          "Cannot integrate to a time earlier than t0 (" << grid_.front() << ")");
    casadi_assert_message(t<=grid_.back() || !stop_at_end_, "IdasInterface::integrate("
                          << t << "): "
                          "Cannot integrate past a time later than tf (" << grid_.back() << ") "
                          "unless stop_at_end is set to False.");

    // Integrate, unless already at desired time
    double ttol = 1e-9;   // tolerance
    if (fabs(m->t-t)>=ttol) {
      // Integrate forward ...
      if (nrx_>0) {
        // ... with taping
        int flag = IDASolveF(m->mem, t, &m->t, m->xz, m->xzdot, IDA_NORMAL, &m->ncheck);
        if (flag != IDA_SUCCESS && flag != IDA_TSTOP_RETURN) idas_error("IDASolveF", flag);
      } else {
        // ... without taping
        int flag = IDASolve(m->mem, t, &m->t, m->xz, m->xzdot, IDA_NORMAL);
        if (flag != IDA_SUCCESS && flag != IDA_TSTOP_RETURN) idas_error("IDASolve", flag);
      }

      // Get quadratures
      if (nq_>0) {
        double tret;
        int flag = IDAGetQuad(m->mem, &tret, m->q);
        if (flag != IDA_SUCCESS) idas_error("IDAGetQuad", flag);
      }
    }

    // Set function outputs
    casadi_copy(NV_DATA_S(m->xz), nx_, x);
    casadi_copy(NV_DATA_S(m->xz)+nx_, nz_, z);
    casadi_copy(NV_DATA_S(m->q), nq_, q);

    // Print statistics
    if (print_stats_) printStats(m, userOut());

    if (gather_stats_) {
      int flag = IDAGetIntegratorStats(m->mem, &m->nsteps, &m->nfevals, &m->nlinsetups,
                                       &m->netfails, &m->qlast, &m->qcur, &m->hinused,
                                       &m->hlast, &m->hcur, &m->tcur);
      if (flag!=IDA_SUCCESS) idas_error("IDAGetIntegratorStats", flag);
    }
  }

  void IdasInterface::resetB(IntegratorMemory* mem, double t, const double* rx,
                             const double* rz, const double* rp) const {
    log("IdasInterface::resetB", "begin");
    auto m = static_cast<IdasMemory*>(mem);

    // Reset the base classes
    SundialsInterface::resetB(mem, t, rx, rz, rp);

    int flag;

    // Reset adjoint sensitivities for the parameters
    if (m->isInitAdj) {
      flag = IDAReInitB(m->mem, m->whichB, grid_.back(), m->rxz, m->rxzdot);
      if (flag != IDA_SUCCESS) idas_error("IDAReInitB", flag);

      if (nrq_>0) {
        flag = IDAQuadReInit(IDAGetAdjIDABmem(m->mem, m->whichB), m->rq);
        // flag = IDAQuadReInitB(m->mem, m->whichB[dir], m->rq[dir]); // BUG in Sundials
        //                                                      // do not use this!
      }
      if (flag!=IDA_SUCCESS) idas_error("IDAQuadReInitB", flag);
    } else {
      // Initialize the adjoint integration
      initAdj(m);
    }

    // Correct initial values for the integration if necessary
    if (calc_icB_) {
      log("IdasInterface::resetB", "IDACalcICB begin");
      flag = IDACalcICB(m->mem, m->whichB, grid_.front(), m->xz, m->xzdot);
      if (flag != IDA_SUCCESS) idas_error("IDACalcICB", flag);
      log("IdasInterface::resetB", "IDACalcICB end");

      // Retrieve the initial values
      flag = IDAGetConsistentICB(m->mem, m->whichB, m->rxz, m->rxzdot);
      if (flag != IDA_SUCCESS) idas_error("IDAGetConsistentICB", flag);

    }

    log("IdasInterface::resetB", "end");

  }

  void IdasInterface::retreat(IntegratorMemory* mem, double t, double* rx,
                              double* rz, double* rq) const {
    auto m = static_cast<IdasMemory*>(mem);

    // Integrate, unless already at desired time
    if (t<m->t) {
      int flag = IDASolveB(m->mem, t, IDA_NORMAL);
      if (flag<IDA_SUCCESS) idas_error("IDASolveB", flag);

      // Get backward state
      flag = IDAGetB(m->mem, m->whichB, &m->t, m->rxz, m->rxzdot);
      if (flag!=IDA_SUCCESS) idas_error("IDAGetB", flag);

      // Get backward qudratures
      if (nrq_>0) {
        flag = IDAGetQuadB(m->mem, m->whichB, &m->t, m->rq);
        if (flag!=IDA_SUCCESS) idas_error("IDAGetQuadB", flag);
      }
    }

    // Save outputs
    casadi_copy(NV_DATA_S(m->rxz), nrx_, rx);
    casadi_copy(NV_DATA_S(m->rxz)+nrx_, nrz_, rz);
    casadi_copy(NV_DATA_S(m->rq), nrq_, rq);

    if (gather_stats_) {
      IDAMem IDA_mem = IDAMem(m->mem);
      IDAadjMem IDAADJ_mem = IDA_mem->ida_adj_mem;
      IDABMem IDAB_mem = IDAADJ_mem->IDAB_mem;
      int flag = IDAGetIntegratorStats(IDAB_mem->IDA_mem, &m->nstepsB, &m->nfevalsB,
                                       &m->nlinsetupsB,
                                       &m->netfailsB, &m->qlastB, &m->qcurB, &m->hinusedB,
                                       &m->hlastB,
                                       &m->hcurB, &m->tcurB);
      if (flag!=IDA_SUCCESS) idas_error("IDAGetIntegratorStatsB", flag);
    }
  }

  void IdasInterface::printStats(IntegratorMemory* mem, std::ostream &stream) const {
    auto m = static_cast<IdasMemory*>(mem);

    long nsteps, nfevals, nlinsetups, netfails;
    int qlast, qcur;
    double hinused, hlast, hcur, tcur;
    int flag = IDAGetIntegratorStats(m->mem, &nsteps, &nfevals, &nlinsetups, &netfails, &qlast,
                                     &qcur, &hinused, &hlast, &hcur, &tcur);
    if (flag!=IDA_SUCCESS) idas_error("IDAGetIntegratorStats", flag);

    // Get the number of right hand side evaluations in the linear solver
    long nfevals_linsol=0;
    switch (linsol_f_) {
    case SD_DENSE:
    case SD_BANDED:
      flag = IDADlsGetNumResEvals(m->mem, &nfevals_linsol);
      if (flag!=IDA_SUCCESS) idas_error("IDADlsGetNumResEvals", flag);
      break;
    case SD_ITERATIVE:
      flag = IDASpilsGetNumResEvals(m->mem, &nfevals_linsol);
      if (flag!=IDA_SUCCESS) idas_error("IDASpilsGetNumResEvals", flag);
      break;
    default:
      nfevals_linsol = 0;
    }

    stream << "number of steps taken by IDAS:            " << nsteps << std::endl;
    stream << "number of calls to the user's f function: " << (nfevals + nfevals_linsol)
           << std::endl;
    stream << "   step calculation:                      " << nfevals << std::endl;
    stream << "   linear solver:                         " << nfevals_linsol << std::endl;
    stream << "number of calls made to the linear solver setup function: " << nlinsetups
           << std::endl;
    stream << "number of error test failures: " << netfails << std::endl;
    stream << "method order used on the last internal step: " << qlast << std::endl;
    stream << "method order to be used on the next internal step: " << qcur << std::endl;
    stream << "actual value of initial step size: " << hinused << std::endl;
    stream << "step size taken on the last internal step: " << hlast << std::endl;
    stream << "step size to be attempted on the next internal step: " << hcur << std::endl;
    stream << "current internal time reached: " << tcur << std::endl;
    stream << std::endl;

    stream << "number of checkpoints stored: " << m->ncheck << endl;
    stream << std::endl;

    stream << "Time spent in the DAE residual: " << m->t_res << " s." << endl;
    stream << "Time spent in the forward sensitivity residual: " << m->t_fres << " s." << endl;
    stream << "Time spent in the jacobian function or jacobian times vector function: "
           << m->t_jac << " s." << endl;
    stream << "Time spent in the linear solver solve function: " << m->t_lsolve << " s." << endl;
    stream << "Time spent to generate the jacobian in the linear solver setup function: "
           << m->t_lsetup_jac << " s." << endl;
    stream << "Time spent to factorize the jacobian in the linear solver setup function: "
           << m->t_lsetup_fac << " s." << endl;
    stream << std::endl;
  }

  void IdasInterface::idas_error(const string& module, int flag) {
    // Find the error
    char* flagname = IDAGetReturnFlagName(flag);
    stringstream ss;
    ss << "Module \"" << module << "\" returned flag " << flag << " (\"" << flagname << "\").";
    ss << " Consult Idas documentation." << std::endl;
    free(flagname);

    // Heuristics
    if (
        (module=="IDACalcIC" && (flag==IDA_CONV_FAIL || flag==IDA_NO_RECOVERY ||
                                 flag==IDA_LINESEARCH_FAIL)) ||
        (module=="IDASolve" && flag ==IDA_ERR_FAIL)
        ) {
      ss << "Some common causes for this error: " << std::endl;
      ss << "  - providing an initial guess for which 0=g(y, z, t) is not invertible wrt y. "
         << std::endl;
      ss << "  - having a DAE-index higher than 1 such that 0=g(y, z, t) is not invertible wrt y "
          "over the whole domain." << std::endl;
      ss << "  - having set abstol or reltol too small." << std::endl;
      ss << "  - using 'calcic'=True for systems that are not semi-explicit index-one. "
          "You must provide consistent initial conditions yourself in this case. " << std::endl;
      ss << "  - your problem is too hard for IDAcalcIC to solve. Provide consistent "
          "initial conditions yourself." << std::endl;
    }

    casadi_error(ss.str());
  }

  int IdasInterface::rhsQ_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector rhsQ,
                                 void *user_data) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.rhsQ(m, t, xz, xzdot, rhsQ);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "rhsQ failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::
  rhsQ(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rhsQ) const {
    log("IdasInterface::rhsQ", "begin");

    // Evaluate f_
    m->arg[DAE_T] = &t;
    m->arg[DAE_X] = NV_DATA_S(xz);
    m->arg[DAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[DAE_P] = get_ptr(m->p);
    m->res[DAE_ODE] = 0;
    m->res[DAE_ALG] = 0;
    m->res[DAE_QUAD] = NV_DATA_S(rhsQ);
    f_(m->arg, m->res, m->iw, m->w, 0);

    log("IdasInterface::rhsQ", "end");
  }

  void IdasInterface::
  rhsQS(IdasMemory* m, int Ns, double t, N_Vector xz, N_Vector xzdot, N_Vector *xzF,
        N_Vector *xzdotF, N_Vector rrQ, N_Vector *qdotF,
        N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) const {

    log("IdasInterface::rhsQS", "enter");

    // Commented out since a new implementation currently cannot be tested
    casadi_error("Commented out, #884, #794.");

    log("IdasInterface::rhsQS", "end");
  }

  int IdasInterface::rhsQS_wrapper(int Ns, double t, N_Vector xz, N_Vector xzdot, N_Vector *xzF,
                                  N_Vector *xzdotF, N_Vector rrQ, N_Vector *qdotF, void *user_data,
                                  N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {

    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.rhsQS(m, Ns, t, xz, xzdot, xzF, xzdotF, rrQ, qdotF, tmp1, tmp2, tmp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "rhsQS failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::resB(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rxz,
                           N_Vector rxzdot, N_Vector rr) const {
    log("IdasInterface::resB", "begin");

    // Debug output
    if (monitored("resB")) {
      printvar("t", t);
      printvar("xz", xz);
      printvar("xzdot", xzdot);
      printvar("rxz", rxz);
      printvar("rxzdot", rxzdot);
    }

    // Evaluate g_
    m->arg[RDAE_T] = &t;
    m->arg[RDAE_X] = NV_DATA_S(xz);
    m->arg[RDAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[RDAE_P] = get_ptr(m->p);
    m->arg[RDAE_RX] = NV_DATA_S(rxz);
    m->arg[RDAE_RZ] = NV_DATA_S(rxz)+nrx_;
    m->arg[RDAE_RP] = get_ptr(m->rp);
    m->res[RDAE_ODE] = NV_DATA_S(rr);
    m->res[RDAE_ALG] = NV_DATA_S(rr) + nrx_;
    m->res[RDAE_QUAD] = 0;
    g_(m->arg, m->res, m->iw, m->w, 0);

    // Subtract state derivative to get residual
    casadi_axpy(nrx_, 1., NV_DATA_S(rxzdot), NV_DATA_S(rr));

    // Debug output
    if (monitored("resB")) {
      printvar("rr", rr);
    }

    log("IdasInterface::resB", "end");
  }

  int IdasInterface::resB_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector xzA,
                                 N_Vector xzdotA, N_Vector rrA, void *user_data) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.resB(m, t, xz, xzdot, xzA, xzdotA, rrA);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "resB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::rhsQB(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector xzA,
                            N_Vector xzdotA, N_Vector qdotA) const {
    log("IdasInterface::rhsQB", "begin");

    // Debug output
    if (monitored("rhsQB")) {
      printvar("t", t);
      printvar("xz", xz);
      printvar("xzdot", xzdot);
      printvar("xzA", xzA);
      printvar("xzdotA", xzdotA);
    }

    // Evaluate g_
    m->arg[RDAE_T] = &t;
    m->arg[RDAE_X] = NV_DATA_S(xz);
    m->arg[RDAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[RDAE_P] = get_ptr(m->p);
    m->arg[RDAE_RX] = NV_DATA_S(xzA);
    m->arg[RDAE_RZ] = NV_DATA_S(xzA)+nrx_;
    m->arg[RDAE_RP] = get_ptr(m->rp);
    m->res[RDAE_ODE] = 0;
    m->res[RDAE_ALG] = 0;
    m->res[RDAE_QUAD] = NV_DATA_S(qdotA);
    g_(m->arg, m->res, m->iw, m->w, 0);

    // Debug output
    if (monitored("rhsQB")) {
      printvar("qdotA", qdotA);
    }

    // Negate (note definition of g)
    casadi_scal(nrq_, -1., NV_DATA_S(qdotA));

    log("IdasInterface::rhsQB", "end");
  }

  int IdasInterface::rhsQB_wrapper(double t, N_Vector y, N_Vector xzdot, N_Vector xzA,
                                  N_Vector xzdotA, N_Vector qdotA, void *user_data) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.rhsQB(m, t, y, xzdot, xzA, xzdotA, qdotA);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "rhsQB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::
  djac(IdasMemory* m, long Neq, double t, double cj, N_Vector xz, N_Vector xzdot,
       N_Vector rr, DlsMat Jac,
       N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) const {
    log("IdasInterface::djac", "begin");

    // Get time
    m->time1 = clock();

    // Evaluate jac_
    m->arg[DAE_T] = &t;
    m->arg[DAE_X] = NV_DATA_S(xz);
    m->arg[DAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[DAE_P] = get_ptr(m->p);
    m->arg[DAE_NUM_IN] = &cj;
    fill_n(m->res, jac_.n_out(), nullptr);
    m->res[0] = m->w + jac_.sz_w();
    jac_(m->arg, m->res, m->iw, m->w, 0);

    // Get sparsity and non-zero elements
    const int* colind = jac_.sparsity_out(0).colind();
    int ncol = jac_.size2_out(0);
    const int* row = jac_.sparsity_out(0).row();
    double *val = m->res[0];

    // Loop over columns
    for (int cc=0; cc<ncol; ++cc) {
      // Loop over non-zero entries
      for (int el=colind[cc]; el<colind[cc+1]; ++el) {

        // Get row
        int rr = row[el];

        // Add to the element
        DENSE_ELEM(Jac, rr, cc) = val[el];
      }
    }

    // Log time duration
    m->time2 = clock();
    m->t_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::djac", "end");
  }

  int IdasInterface::djac_wrapper(long Neq, double t, double cj, N_Vector xz, N_Vector xzdot,
                                 N_Vector rr, DlsMat Jac, void *user_data,
                                 N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.djac(m, Neq, t, cj, xz, xzdot, rr, Jac, tmp1, tmp2, tmp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "djac failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::
  djacB(IdasMemory* m, long int NeqB, double t, double cjB, N_Vector xz, N_Vector xzdot,
        N_Vector xzB, N_Vector xzdotB, N_Vector rrB, DlsMat JacB,
        N_Vector tmp1B, N_Vector tmp2B, N_Vector tmp3B) const {
    log("IdasInterface::djacB", "begin");

    // Get time
    m->time1 = clock();

    // Evaluate jacB_
    m->arg[RDAE_T] = &t;
    m->arg[RDAE_X] = NV_DATA_S(xz);
    m->arg[RDAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[RDAE_P] = get_ptr(m->p);
    m->arg[RDAE_RX] = NV_DATA_S(xzB);
    m->arg[RDAE_RZ] = NV_DATA_S(xzB)+nrx_;
    m->arg[RDAE_RP] = get_ptr(m->rp);
    m->arg[RDAE_NUM_IN] = &cjB;
    fill_n(m->res, jacB_.n_out(), nullptr);
    m->res[0] = m->w + jacB_.sz_w();
    jacB_(m->arg, m->res, m->iw, m->w, 0);

    // Get sparsity and non-zero elements
    const int* colind = jacB_.sparsity_out(0).colind();
    int ncol = jacB_.size2_out(0);
    const int* row = jacB_.sparsity_out(0).row();
    double *val = m->res[0];

    // Loop over columns
    for (int cc=0; cc<ncol; ++cc) {
      // Loop over non-zero entries
      for (int el=colind[cc]; el<colind[cc+1]; ++el) {

        // Get row
        int rr = row[el];

        // Add to the element
        DENSE_ELEM(JacB, rr, cc) = val[el];
      }
    }

    // Log time duration
    m->time2 = clock();
    m->t_jacB += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::djacB", "end");
  }

  int IdasInterface::djacB_wrapper(long int NeqB, double t, double cjB, N_Vector xz, N_Vector xzdot,
                                  N_Vector xzB, N_Vector xzdotB, N_Vector rrB, DlsMat JacB,
                                  void *user_data,
                                  N_Vector tmp1B, N_Vector tmp2B, N_Vector tmp3B) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.djacB(m, NeqB, t, cjB, xz, xzdot, xzB, xzdotB, rrB, JacB, tmp1B, tmp2B, tmp3B);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "djacB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::bjac(IdasMemory* m, long Neq, long mupper, long mlower, double t, double cj,
                           N_Vector xz, N_Vector xzdot, N_Vector rr, DlsMat Jac,
                           N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) const {
    log("IdasInterface::bjac", "begin");
    // Get time
    m->time1 = clock();

    // Evaluate jac_
    m->arg[DAE_T] = &t;
    m->arg[DAE_X] = NV_DATA_S(xz);
    m->arg[DAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[DAE_P] = get_ptr(m->p);
    m->arg[DAE_NUM_IN] = &cj;
    fill_n(m->res, jac_.n_out(), nullptr);
    m->res[0] = m->w + jac_.sz_w();
    jac_(m->arg, m->res, m->iw, m->w, 0);

    // Get sparsity and non-zero elements
    const int* colind = jac_.sparsity_out(0).colind();
    int ncol = jac_.size2_out(0);
    const int* row = jac_.sparsity_out(0).row();
    double *val = m->res[0];

    // Loop over columns
    for (int cc=0; cc<ncol; ++cc) {
      // Loop over non-zero entries
      for (int el=colind[cc]; el<colind[cc+1]; ++el) {
        // Get row
        int rr = row[el];

        // Set the element
        if (cc-rr<=mupper && rr-cc<=mlower)
          BAND_ELEM(Jac, rr, cc) = val[el];
      }
    }

    // Log time duration
    m->time2 = clock();
    m->t_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::bjac", "end");
  }

  int IdasInterface::bjac_wrapper(long Neq, long mupper, long mlower, double t, double cj,
                                 N_Vector xz, N_Vector xzdot, N_Vector rr,
                                 DlsMat Jac, void *user_data,
                                 N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.bjac(m, Neq, mupper, mlower, t, cj, xz, xzdot, rr, Jac, tmp1, tmp2, tmp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "bjac failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::bjacB(IdasMemory* m, long NeqB, long mupperB, long mlowerB, double t,
                            double cjB, N_Vector xz, N_Vector xzdot, N_Vector xzB, N_Vector xzdotB,
                            N_Vector resvalB, DlsMat JacB, N_Vector tmp1B, N_Vector tmp2B,
                            N_Vector tmp3B) const {
    log("IdasInterface::bjacB", "begin");

    // Get time
    m->time1 = clock();

    // Evaluate jacB_
    m->arg[RDAE_T] = &t;
    m->arg[RDAE_X] = NV_DATA_S(xz);
    m->arg[RDAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[RDAE_P] = get_ptr(m->p);
    m->arg[RDAE_RX] = NV_DATA_S(xzB);
    m->arg[RDAE_RZ] = NV_DATA_S(xzB)+nrx_;
    m->arg[RDAE_RP] = get_ptr(m->rp);
    m->arg[RDAE_NUM_IN] = &cjB;
    fill_n(m->res, jacB_.n_out(), nullptr);
    m->res[0] = m->w + jacB_.sz_w();
    jacB_(m->arg, m->res, m->iw, m->w, 0);

    // Get sparsity and non-zero elements
    const int* colind = jacB_.sparsity_out(0).colind();
    int ncol = jacB_.size2_out(0);
    const int* row = jacB_.sparsity_out(0).row();
    double *val = m->res[0];

    // Loop over columns
    for (int cc=0; cc<ncol; ++cc) {
      // Loop over non-zero entries
      for (int el=colind[cc]; el<colind[cc+1]; ++el) {
        // Get row
        int rr = row[el];

        // Set the element
        if (cc-rr<=mupperB && rr-cc<=mlowerB)
          BAND_ELEM(JacB, rr, cc) = val[el];
      }
    }

    // Log time duration
    m->time2 = clock();
    m->t_jacB += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::bjacB", "end");
  }

  int IdasInterface::
  bjacB_wrapper(long NeqB, long mupperB, long mlowerB, double t, double cjB,
                N_Vector xz, N_Vector xzdot, N_Vector xzB, N_Vector xzdotB,
                N_Vector resvalB, DlsMat JacB, void *user_data, N_Vector tmp1B,
                N_Vector tmp2B, N_Vector tmp3B) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      m->self.bjacB(m, NeqB, mupperB, mlowerB, t, cjB, xz, xzdot, xzB, xzdotB,
                   resvalB, JacB, tmp1B, tmp2B, tmp3B);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "bjacB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::setStopTime(IntegratorMemory* mem, double tf) const {
    // Set the stop time of the integration -- don't integrate past this point
    auto m = static_cast<IdasMemory*>(mem);
    int flag = IDASetStopTime(m->mem, tf);
    if (flag != IDA_SUCCESS) idas_error("IDASetStopTime", flag);
  }

  int IdasInterface::psolve_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector rr,
                                    N_Vector rvec, N_Vector zvec, double cj, double delta,
                                    void *user_data, N_Vector tmp) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      casadi_assert(m);
      m->self.psolve(m, t, xz, xzdot, rr, rvec, zvec, cj, delta, tmp);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "psolve failed: " << e.what() << endl;
      return 1;
    }
  }

  int IdasInterface::psolveB_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector xzB,
                                    N_Vector xzdotB, N_Vector resvalB, N_Vector rvecB,
                                    N_Vector zvecB, double cjB, double deltaB,
                                    void *user_data, N_Vector tmpB) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      casadi_assert(m);
      m->self.psolveB(m, t, xz, xzdot, xzB, xzdotB, resvalB, rvecB, zvecB, cjB, deltaB, tmpB);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "psolveB failed: " << e.what() << endl;
      return 1;
    }
  }

  int IdasInterface::psetup_wrapper(double t, N_Vector xz, N_Vector xzdot, N_Vector rr,
                                   double cj, void* user_data,
                                   N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      casadi_assert(m);
      m->self.psetup(m, t, xz, xzdot, rr, cj, tmp1, tmp2, tmp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "psetup failed: " << e.what() << endl;
      return 1;
    }
  }

  int IdasInterface::psetupB_wrapper(double t, N_Vector xz, N_Vector xzdot,
                                    N_Vector xzB, N_Vector xzdotB,
                                    N_Vector resvalB, double cjB, void *user_data,
                                    N_Vector tmp1B, N_Vector tmp2B, N_Vector tmp3B) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(user_data);
      casadi_assert(m);
      m->self.psetupB(m, t, xz, xzdot, xzB, xzdotB, resvalB, cjB, tmp1B, tmp2B, tmp3B);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "psetupB failed: " << e.what() << endl;
      return 1;
    }
  }

  void IdasInterface::
  psolve(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rr, N_Vector rvec,
         N_Vector zvec, double cj, double delta, N_Vector tmp) const {
    log("IdasInterface::psolve", "begin");

    // Get time
    m->time1 = clock();

    // Copy input to output, if necessary
    if (rvec!=zvec) {
      N_VScale(1.0, rvec, zvec);
    }

    // Solve the (possibly factorized) system
    casadi_assert_message(linsol_.nnz_out(0) == NV_LENGTH_S(zvec), "Assertion error: "
                          << linsol_.nnz_out(0) << " == " << NV_LENGTH_S(zvec));
    linsol_.linsol_solve(NV_DATA_S(zvec));

    // Log time duration
    m->time2 = clock();
    m->t_lsolve += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::psolve", "end");
  }


  void IdasInterface::
  psolveB(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector xzB, N_Vector xzdotB,
          N_Vector resvalB, N_Vector rvecB, N_Vector zvecB,
          double cjB, double deltaB, N_Vector tmpB) const {
    log("IdasInterface::psolveB", "begin");

    // Get time
    m->time1 = clock();

    // Copy input to output, if necessary
    if (rvecB!=zvecB) {
      N_VScale(1.0, rvecB, zvecB);
    }

    casadi_assert(!linsolB_.is_null());

    // Solve the (possibly factorized) system
    casadi_assert_message(linsolB_.nnz_out(0) == NV_LENGTH_S(zvecB),
                          "Assertion error: " << linsolB_.nnz_out(0)
                          << " == " << NV_LENGTH_S(zvecB));
    if (monitored("psolveB")) {
      userOut() << "zvecB = " << std::endl;
      for (int k=0;k<NV_LENGTH_S(zvecB);++k) {
        userOut() << NV_DATA_S(zvecB)[k] << " " ;
      }
      userOut() << endl;
    }

    linsolB_.linsol_solve(NV_DATA_S(zvecB));

    if (monitored("psolveB")) {
      userOut() << "zvecB sol = " << std::endl;
      for (int k=0;k<NV_LENGTH_S(zvecB);++k) {
        userOut() << NV_DATA_S(zvecB)[k] << " " ;
      }
      userOut() << endl;
    }

    // Log time duration
    m->time2 = clock();
    m->t_lsolve += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;
    log("IdasInterface::psolveB", "end");
  }

  void IdasInterface::
  psetup(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector rr, double cj,
         N_Vector tmp1, N_Vector tmp2, N_Vector tmp3) const {
    log("IdasInterface::psetup", "begin");

    // Get time
    m->time1 = clock();

    // Evaluate jac_
    m->arg[DAE_T] = &t;
    m->arg[DAE_X] = NV_DATA_S(xz);
    m->arg[DAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[DAE_P] = get_ptr(m->p);
    m->arg[DAE_NUM_IN] = &cj;
    fill_n(m->res, jac_.n_out(), nullptr);
    double *val = m->w;
    double *w2 = m->w + jac_.nnz_out(0);
    m->res[0] = val;
    jac_(m->arg, m->res, m->iw, w2, 0);

    // Log time duration
    m->time2 = clock();
    m->t_lsetup_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;

    // Prepare the solution of the linear system (e.g. factorize)
    linsol_.setup(m->arg+LINSOL_NUM_IN, m->res+LINSOL_NUM_OUT, m->iw, w2);
    linsol_.linsol_factorize(val);

    // Log time duration
    m->time1 = clock();
    m->t_lsetup_fac += static_cast<double>(m->time1-m->time2)/CLOCKS_PER_SEC;

    log("IdasInterface::psetup", "end");

  }


  void IdasInterface::
  psetupB(IdasMemory* m, double t, N_Vector xz, N_Vector xzdot, N_Vector xzB, N_Vector xzdotB,
          N_Vector resvalB, double cjB,
          N_Vector tmp1B, N_Vector tmp2B, N_Vector tmp3B) const {
    log("IdasInterface::psetupB", "begin");

    // Get time
    m->time1 = clock();

    // Evaluate jacB_
    m->arg[RDAE_T] = &t;
    m->arg[RDAE_X] = NV_DATA_S(xz);
    m->arg[RDAE_Z] = NV_DATA_S(xz)+nx_;
    m->arg[RDAE_P] = get_ptr(m->p);
    m->arg[RDAE_RX] = NV_DATA_S(xzB);
    m->arg[RDAE_RZ] = NV_DATA_S(xzB)+nrx_;
    m->arg[RDAE_RP] = get_ptr(m->rp);
    m->arg[RDAE_NUM_IN] = &cjB;
    fill_n(m->res, jacB_.n_out(), nullptr);
    double *val = m->w;
    double *w2 = m->w + jacB_.nnz_out(0);
    m->res[0] = val;
    jacB_(m->arg, m->res, m->iw, w2, 0);

    // Log time duration
    m->time2 = clock();
    m->t_lsetup_jac += static_cast<double>(m->time2-m->time1)/CLOCKS_PER_SEC;

    // Prepare the solution of the linear system (e.g. factorize)
    linsolB_.setup(m->arg+LINSOL_NUM_IN, m->res+LINSOL_NUM_OUT, m->iw, w2);
    linsolB_.linsol_factorize(val);

    // Log time duration
    m->time1 = clock();
    m->t_lsetup_fac += static_cast<double>(m->time1-m->time2)/CLOCKS_PER_SEC;

    log("IdasInterface::psetupB", "end");
  }

  int IdasInterface::lsetup_wrapper(IDAMem IDA_mem, N_Vector xz, N_Vector xzdot, N_Vector resp,
                                    N_Vector vtemp1, N_Vector vtemp2, N_Vector vtemp3) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(IDA_mem->ida_lmem);
      casadi_assert(m);
      m->self.lsetup(m, IDA_mem, xz, xzdot, resp, vtemp1, vtemp2, vtemp3);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "lsetup failed: " << e.what() << endl;
      return -1;
    }
  }

  int IdasInterface::lsetupB_wrapper(IDAMem IDA_mem, N_Vector xzB, N_Vector xzdotB, N_Vector respB,
                                     N_Vector vtemp1B, N_Vector vtemp2B, N_Vector vtemp3B) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(IDA_mem->ida_lmem);
      casadi_assert(m);
      IDAadjMem IDAADJ_mem;
      //IDABMem IDAB_mem;
      int flag;

      // Current time
      double t = IDA_mem->ida_tn; // TODO(Joel): is this correct?
      // Multiple of df_dydot to be added to the matrix
      double cj = IDA_mem->ida_cj;

      IDA_mem = static_cast<IDAMem>(IDA_mem->ida_user_data);

      IDAADJ_mem = IDA_mem->ida_adj_mem;
      //IDAB_mem = IDAADJ_mem->ia_bckpbCrt;

      // Get FORWARD solution from interpolation.
      if (IDAADJ_mem->ia_noInterp==FALSE) {
        flag = IDAADJ_mem->ia_getY(IDA_mem, t, IDAADJ_mem->ia_yyTmp, IDAADJ_mem->ia_ypTmp,
                                   NULL, NULL);
        if (flag != IDA_SUCCESS) casadi_error("Could not interpolate forward states");
      }
      m->self.lsetupB(m, t, cj, IDAADJ_mem->ia_yyTmp,
                      IDAADJ_mem->ia_ypTmp, xzB, xzdotB, respB, vtemp1B, vtemp2B, vtemp3B);
      return 0;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "lsetupB failed: " << e.what() << endl;
      return -1;
    }
  }


  int IdasInterface::lsolve_wrapper(IDAMem IDA_mem, N_Vector b, N_Vector weight, N_Vector xz,
                                   N_Vector xzdot, N_Vector rr) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(IDA_mem->ida_lmem);
      casadi_assert(m);
      m->self.lsolve(m, IDA_mem, b, weight, xz, xzdot, rr);
      return 0;
    } catch(int wrn) {
      /*    userOut<true, PL_WARN>() << "warning: " << wrn << endl;*/
      return wrn;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "lsolve failed: " << e.what() << endl;
      return -1;
    }
  }

  int IdasInterface::lsolveB_wrapper(IDAMem IDA_mem, N_Vector b, N_Vector weight, N_Vector xzB,
                                    N_Vector xzdotB, N_Vector rrB) {
    try {
      IdasMemory* m = static_cast<IdasMemory*>(IDA_mem->ida_lmem);
      casadi_assert(m);
      IDAadjMem IDAADJ_mem;
      //IDABMem IDAB_mem;
      int flag;

      // Current time
      double t = IDA_mem->ida_tn; // TODO(Joel): is this correct?
      // Multiple of df_dydot to be added to the matrix
      double cj = IDA_mem->ida_cj;
      double cjratio = IDA_mem->ida_cjratio;

      IDA_mem = (IDAMem) IDA_mem->ida_user_data;

      IDAADJ_mem = IDA_mem->ida_adj_mem;
      //IDAB_mem = IDAADJ_mem->ia_bckpbCrt;

      // Get FORWARD solution from interpolation.
      if (IDAADJ_mem->ia_noInterp==FALSE) {
        flag = IDAADJ_mem->ia_getY(IDA_mem, t, IDAADJ_mem->ia_yyTmp, IDAADJ_mem->ia_ypTmp,
                                   NULL, NULL);
        if (flag != IDA_SUCCESS) casadi_error("Could not interpolate forward states");
      }
      m->self.lsolveB(m, t, cj, cjratio, b, weight, IDAADJ_mem->ia_yyTmp,
                     IDAADJ_mem->ia_ypTmp, xzB, xzdotB, rrB);
      return 0;
    } catch(int wrn) {
      /*    userOut<true, PL_WARN>() << "warning: " << wrn << endl;*/
      return wrn;
    } catch(exception& e) {
      userOut<true, PL_WARN>() << "lsolveB failed: " << e.what() << endl;
      return -1;
    }
  }

  void IdasInterface::
  lsetup(IdasMemory* m, IDAMem IDA_mem, N_Vector xz, N_Vector xzdot, N_Vector resp,
         N_Vector vtemp1, N_Vector vtemp2, N_Vector vtemp3) const {
    log("IdasInterface::lsetup", "begin");

    // Current time
    double t = IDA_mem->ida_tn;

    // Multiple of df_dydot to be added to the matrix
    double cj = IDA_mem->ida_cj;

    // Call the preconditioner setup function (which sets up the linear solver)
    psetup(m, t, xz, xzdot, 0, cj, vtemp1, vtemp1, vtemp3);
    log("IdasInterface::lsetup", "end");
  }

  void IdasInterface::
  lsetupB(IdasMemory* m, double t, double cj, N_Vector xz, N_Vector xzdot, N_Vector xzB,
          N_Vector xzdotB, N_Vector resp,
          N_Vector vtemp1, N_Vector vtemp2, N_Vector vtemp3) const {
    log("IdasInterface::lsetupB", "begin");

    // Call the preconditioner setup function (which sets up the linear solver)
    psetupB(m, t, xz, xzdot, xzB, xzdotB, 0, cj, vtemp1, vtemp1, vtemp3);
    log("IdasInterface::lsetupB", "end");
  }


  void IdasInterface::
  lsolve(IdasMemory* m, IDAMem IDA_mem, N_Vector b, N_Vector weight, N_Vector xz,
         N_Vector xzdot, N_Vector rr) const {
    log("IdasInterface::lsolve", "begin");
    // Current time
    double t = IDA_mem->ida_tn;

    // Multiple of df_dydot to be added to the matrix
    double cj = IDA_mem->ida_cj;

    // Accuracy
    double delta = 0.0;

    // Call the preconditioner solve function (which solves the linear system)
    psolve(m, t, xz, xzdot, rr, b, b, cj, delta, 0);

    // Scale the correction to account for change in cj
    if (cj_scaling_) {
      double cjratio = IDA_mem->ida_cjratio;
      if (cjratio != 1.0) N_VScale(2.0/(1.0 + cjratio), b, b);
    }
    log("IdasInterface::lsolve", "end");
  }

  void IdasInterface::
  lsolveB(IdasMemory* m, double t, double cj, double cjratio, N_Vector b, N_Vector weight,
          N_Vector xz, N_Vector xzdot, N_Vector xzB, N_Vector xzdotB,
          N_Vector rr) const {
    log("IdasInterface::lsolveB", "begin");

    // Accuracy
    double delta = 0.0;

    // Call the preconditioner solve function (which solves the linear system)
    psolveB(m, t, xz, xzdot, xzB, xzdotB, rr, b, b, cj, delta, 0);

    // Scale the correction to account for change in cj
    if (cj_scaling_) {
      if (cjratio != 1.0) N_VScale(2.0/(1.0 + cjratio), b, b);
    }

    log("IdasInterface::lsolveB", "end");
  }


  void IdasInterface::initDenseLinsol(IdasMemory* m) const {
    // Dense jacobian
    int flag = IDADense(m->mem, nx_+nz_);
    if (flag != IDA_SUCCESS) idas_error("IDADense", flag);
    if (exact_jacobian_) {
      flag = IDADlsSetDenseJacFn(m->mem, djac_wrapper);
      if (flag!=IDA_SUCCESS) idas_error("IDADlsSetDenseJacFn", flag);
    }
  }

  void IdasInterface::initBandedLinsol(IdasMemory* m) const {
    // Banded jacobian
    pair<int, int> bw = getBandwidth();
    int flag = IDABand(m->mem, nx_+nz_, bw.first, bw.second);
    if (flag != IDA_SUCCESS) idas_error("IDABand", flag);

    // Banded Jacobian information
    if (exact_jacobian_) {
      flag = IDADlsSetBandJacFn(m->mem, bjac_wrapper);
      if (flag != IDA_SUCCESS) idas_error("IDADlsSetBandJacFn", flag);
    }
  }

  void IdasInterface::initIterativeLinsol(IdasMemory* m) const {
    // Attach an iterative solver
    int flag;
    switch (itsol_f_) {
    case SD_GMRES:
      flag = IDASpgmr(m->mem, max_krylov_);
      if (flag != IDA_SUCCESS) idas_error("IDASpgmr", flag);
      break;
    case SD_BCGSTAB:
      flag = IDASpbcg(m->mem, max_krylov_);
      if (flag != IDA_SUCCESS) idas_error("IDASpbcg", flag);
      break;
    case SD_TFQMR:
      flag = IDASptfqmr(m->mem, max_krylov_);
      if (flag != IDA_SUCCESS) idas_error("IDASptfqmr", flag);
      break;
    default: casadi_error("Uncaught switch");
    }

    // Attach functions for jacobian information
    if (exact_jacobian_) {
      flag = IDASpilsSetJacTimesVecFn(m->mem, jtimes_wrapper);
      if (flag != IDA_SUCCESS) idas_error("IDASpilsSetJacTimesVecFn", flag);
    }

    // Add a preconditioner
    if (use_preconditioner_) {
      // Make sure that a Jacobian has been provided
      if (jac_.is_null())
          throw CasadiException("IdasInterface::init(): No Jacobian has been provided.");

      // Make sure that a linear solver has been provided
      if (linsol_.is_null())
          throw CasadiException("IdasInterface::init(): "
                                "No user defined linear solver has been provided.");

      // Pass to IDA
      flag = IDASpilsSetPreconditioner(m->mem, psetup_wrapper, psolve_wrapper);
      if (flag != IDA_SUCCESS) idas_error("IDASpilsSetPreconditioner", flag);
    }
  }

  void IdasInterface::initUserDefinedLinsol(IdasMemory* m) const {
    // Make sure that a Jacobian has been provided
    casadi_assert(!jac_.is_null());

    // Make sure that a linear solver has been provided
    casadi_assert(!linsol_.is_null());

    //  Set fields in the IDA memory
    IDAMem IDA_mem = IDAMem(m->mem);
    IDA_mem->ida_lmem   = m;
    IDA_mem->ida_lsetup = lsetup_wrapper;
    IDA_mem->ida_lsolve = lsolve_wrapper;
    IDA_mem->ida_setupNonNull = TRUE;
  }

  void IdasInterface::initDenseLinsolB(IdasMemory* m) const {
    // Dense jacobian
    int flag = IDADenseB(m->mem, m->whichB, nrx_+nrz_);
    if (flag != IDA_SUCCESS) idas_error("IDADenseB", flag);
    if (exact_jacobianB_) {
      // Pass to IDA
      flag = IDADlsSetDenseJacFnB(m->mem, m->whichB, djacB_wrapper);
      if (flag!=IDA_SUCCESS) idas_error("IDADlsSetDenseJacFnB", flag);
    }
  }

  void IdasInterface::initBandedLinsolB(IdasMemory* m) const {
    pair<int, int> bw = getBandwidthB();
    int flag = IDABandB(m->mem, m->whichB, nrx_+nrz_, bw.first, bw.second);
    if (flag != IDA_SUCCESS) idas_error("IDABand", flag);
    if (exact_jacobianB_) {
      // Pass to IDA
      flag = IDADlsSetBandJacFnB(m->mem, m->whichB, bjacB_wrapper);
      if (flag!=IDA_SUCCESS) idas_error("IDADlsSetBandJacFnB", flag);
    }
  }

  // Workaround for bug in Sundials, to be removed when Debian/Homebrew
  // Sundials have been patched
#ifdef WITH_SYSTEM_SUNDIALS
  extern "C" {

#define yyTmp        (IDAADJ_mem->ia_yyTmp)
#define ypTmp        (IDAADJ_mem->ia_ypTmp)
#define noInterp     (IDAADJ_mem->ia_noInterp)

    static int IDAAspilsJacTimesVecPatched(realtype tt,
                                    N_Vector yyB, N_Vector ypB, N_Vector rrB,
                                    N_Vector vB, N_Vector JvB,
                                    realtype c_jB, void *ida_mem,
                                    N_Vector tmp1B, N_Vector tmp2B) {
      IDAMem IDA_mem;
      IDAadjMem IDAADJ_mem;
      IDASpilsMemB idaspilsB_mem;
      IDABMem IDAB_mem;
      int flag;

      IDA_mem = (IDAMem) ida_mem;
      IDAADJ_mem = IDA_mem->ida_adj_mem;
      IDAB_mem = IDAADJ_mem->ia_bckpbCrt;
      idaspilsB_mem = (IDASpilsMemB)IDAB_mem->ida_lmem;

      /* Get FORWARD solution from interpolation. */
      if (noInterp==FALSE) {
        flag = IDAADJ_mem->ia_getY(IDA_mem, tt, yyTmp, ypTmp, NULL, NULL);
        if (flag != IDA_SUCCESS) {
          IDAProcessError(IDA_mem, -1, "IDASSPILS", "IDAAspilsJacTimesVec", MSGS_BAD_T);
          return(-1);
        }
      }
      /* Call user's adjoint psolveB routine */
      flag = idaspilsB_mem->s_jtimesB(tt, yyTmp, ypTmp,
                                      yyB, ypB, rrB,
                                      vB, JvB,
                                      c_jB, IDAB_mem->ida_user_data,
                                      tmp1B, tmp2B);
      return(flag);
    }

    int IDASpilsSetJacTimesVecFnBPatched(void *ida_mem, int which, IDASpilsJacTimesVecFnB jtvB) {
      IDAadjMem IDAADJ_mem;
      IDAMem IDA_mem;
      IDABMem IDAB_mem;
      IDASpilsMemB idaspilsB_mem;
      void *ida_memB;
      int flag;

      /* Check if ida_mem is allright. */
      if (ida_mem == NULL) {
        IDAProcessError(NULL, IDASPILS_MEM_NULL, "IDASSPILS",
                        "IDASpilsSetJacTimesVecFnB", MSGS_IDAMEM_NULL);
        return(IDASPILS_MEM_NULL);
      }
      IDA_mem = (IDAMem) ida_mem;

      /* Is ASA initialized? */
      if (IDA_mem->ida_adjMallocDone == FALSE) {
        IDAProcessError(IDA_mem, IDASPILS_NO_ADJ, "IDASSPILS",
                        "IDASpilsSetJacTimesVecFnB",  MSGS_NO_ADJ);
        return(IDASPILS_NO_ADJ);
      }
      IDAADJ_mem = IDA_mem->ida_adj_mem;

      /* Check the value of which */
      if ( which >= IDAADJ_mem->ia_nbckpbs ) {
        IDAProcessError(IDA_mem, IDASPILS_ILL_INPUT, "IDASSPILS",
                        "IDASpilsSetJacTimesVecFnB", MSGS_BAD_WHICH);
        return(IDASPILS_ILL_INPUT);
      }

      /* Find the IDABMem entry in the linked list corresponding to 'which'. */
      IDAB_mem = IDAADJ_mem->IDAB_mem;
      while (IDAB_mem != NULL) {
        if ( which == IDAB_mem->ida_index ) break;
        /* advance */
        IDAB_mem = IDAB_mem->ida_next;
      }
      /* ida_mem corresponding to 'which' problem-> */
      ida_memB = reinterpret_cast<void *>(IDAB_mem->IDA_mem);

      if (IDAB_mem->ida_lmem == NULL) {
        IDAProcessError(IDA_mem, IDASPILS_LMEMB_NULL, "IDASSPILS",
                        "IDASpilsSetJacTimesVecFnB", MSGS_LMEMB_NULL);
        return(IDASPILS_ILL_INPUT);
      }

      idaspilsB_mem = (IDASpilsMemB) IDAB_mem->ida_lmem;

      /* Call the corresponding Set* function for the backward problem-> */

      idaspilsB_mem->s_jtimesB   = jtvB;

      if (jtvB != NULL) {
        flag = IDASpilsSetJacTimesVecFn(ida_memB, IDAAspilsJacTimesVecPatched);
      } else {
        flag = IDASpilsSetJacTimesVecFn(ida_memB, NULL);
      }
      return(flag);
    }
  }
#endif // WITH_SYSTEM_SUNDIALS

  void IdasInterface::initIterativeLinsolB(IdasMemory* m) const {
    int flag;
    switch (itsol_g_) {
    case SD_GMRES:
      flag = IDASpgmrB(m->mem, m->whichB, max_krylovB_);
      if (flag != IDA_SUCCESS) idas_error("IDASpgmrB", flag);
      break;
    case SD_BCGSTAB:
      flag = IDASpbcgB(m->mem, m->whichB, max_krylovB_);
      if (flag != IDA_SUCCESS) idas_error("IDASpbcgB", flag);
      break;
    case SD_TFQMR:
      flag = IDASptfqmrB(m->mem, m->whichB, max_krylovB_);
      if (flag != IDA_SUCCESS) idas_error("IDASptfqmrB", flag);
      break;
    default: casadi_error("Uncaught switch");
    }

    // Attach functions for jacobian information
    if (exact_jacobianB_) {
#ifdef WITH_SYSTEM_SUNDIALS
      flag = IDASpilsSetJacTimesVecFnBPatched(m->mem, m->whichB, jtimesB_wrapper);
#else
      flag = IDASpilsSetJacTimesVecFnB(m->mem, m->whichB, jtimesB_wrapper);
#endif
      if (flag != IDA_SUCCESS) idas_error("IDASpilsSetJacTimesVecFnB", flag);
    }

    // Add a preconditioner
    if (use_preconditionerB_) {
      // Make sure that a Jacobian has been provided
      if (jacB_.is_null())
          throw CasadiException("IdasInterface::init(): No backwards Jacobian has been provided.");

      // Make sure that a linear solver has been provided
      if (linsolB_.is_null())
          throw CasadiException("IdasInterface::init(): No backwards user "
                                "defined linear solver has been provided.");

      // Pass to IDA
      flag = IDASpilsSetPreconditionerB(m->mem, m->whichB, psetupB_wrapper, psolveB_wrapper);
      if (flag != IDA_SUCCESS) idas_error("IDASpilsSetPreconditionerB", flag);
    }

  }

  void IdasInterface::initUserDefinedLinsolB(IdasMemory* m) const {
    // Make sure that a Jacobian has been provided
    casadi_assert(!jacB_.is_null());

    // Make sure that a linear solver has been provided
    casadi_assert(!linsolB_.is_null());

    //  Set fields in the IDA memory
    IDAMem IDA_mem = IDAMem(m->mem);
    IDAadjMem IDAADJ_mem = IDA_mem->ida_adj_mem;
    IDABMem IDAB_mem = IDAADJ_mem->IDAB_mem;
    IDAB_mem->ida_lmem   = m;

    IDAB_mem->IDA_mem->ida_lmem = m;
    IDAB_mem->IDA_mem->ida_lsetup = lsetupB_wrapper;
    IDAB_mem->IDA_mem->ida_lsolve = lsolveB_wrapper;
    IDAB_mem->IDA_mem->ida_setupNonNull = TRUE;
  }

  template<typename MatType>
  Function IdasInterface::getJacGen() {
    // Get the Jacobian in the Newton iteration
    MatType cj = MatType::sym("cj");
    MatType jac = MatType::jac(f_, DAE_X, DAE_ODE) - cj*MatType::eye(nx_);
    if (nz_>0) {
      jac = horzcat(vertcat(jac,
                            MatType::jac(f_, DAE_X, DAE_ALG)),
                    vertcat(MatType::jac(f_, DAE_Z, DAE_ODE),
                            MatType::jac(f_, DAE_Z, DAE_ALG)));
    }

    // Jacobian function
    std::vector<MatType> jac_in = MatType::get_input(f_);
    jac_in.push_back(cj);

    // Return generated function
    return Function("jacf", jac_in, {jac});
  }

  template<typename MatType>
  Function IdasInterface::getJacGenB() {
    // Get the Jacobian in the Newton iteration
    MatType cj = MatType::sym("cj");
    MatType jac = MatType::jac(g_, RDAE_RX, RDAE_ODE) + cj*MatType::eye(nrx_);
    if (nrz_>0) {
      jac = horzcat(vertcat(jac,
                            MatType::jac(g_, RDAE_RX, RDAE_ALG)),
                    vertcat(MatType::jac(g_, RDAE_RZ, RDAE_ODE),
                            MatType::jac(g_, RDAE_RZ, RDAE_ALG)));
    }

    // Jacobian function
    std::vector<MatType> jac_in = MatType::get_input(g_);
    jac_in.push_back(cj);

    // return generated function
    return Function("jacg", jac_in, {jac});
  }

  Function IdasInterface::getJacB() {
    if (g_.is_a("sxfunction")) {
      return getJacGenB<SX>();
    } else if (g_.is_a("mxfunction")) {
      return getJacGenB<MX>();
    } else {
      throw CasadiException("IdasInterface::getJacB(): Not an SXFunction or MXFunction");
    }
  }

  Function IdasInterface::getJac() {
    if (f_.is_a("sxfunction")) {
      return getJacGen<SX>();
    } else if (f_.is_a("mxfunction")) {
      return getJacGen<MX>();
    } else {
      throw CasadiException("IdasInterface::getJac(): Not an SXFunction or MXFunction");
    }
  }

  IdasMemory::IdasMemory(const IdasInterface& s) : self(s) {
    this->mem = 0;
    this->xzdot = 0;
    this->rxzdot = 0;
    this->isInitAdj = false;
    this->isInitTaping = false;

    // Reset checkpoints counter
    this->ncheck = 0;
  }

  IdasMemory::~IdasMemory() {
    if (this->mem) IDAFree(&this->mem);
    if (this->xzdot) N_VDestroy_Serial(this->xzdot);
    if (this->rxzdot) N_VDestroy_Serial(this->rxzdot);
  }

  Dict IdasInterface::get_stats(void* mem) const {
    Dict stats = SundialsInterface::get_stats(mem);
    return stats;
  }


} // namespace casadi
