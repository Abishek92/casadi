/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef SCHEMES_HELPERS_HPP
#define SCHEMES_HELPERS_HPP
#include <vector>
#include <string>
#include <utility>
#include <map>
#include "io_scheme_vector.hpp"
namespace casadi {

/// Input arguments of a \e cle solver
///
/// \copydoc scheme_CLEInput
template<class M>
IOSchemeVector<M> cleIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_CLEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in CLEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_CLEInput));
}
/// Output arguments of a \e cle solver
///
/// \copydoc scheme_CLEOutput
template<class M>
IOSchemeVector<M> cleOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_CLEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in CLEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_CLEOutput));
}
/// Structure specification of a CLE
///
/// \copydoc scheme_CleStruct
template<class M>
IOSchemeVector<M> cleStruct(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_CleStruct, it->first);
    if (n==-1)
      casadi_error("Keyword error in CleStruct: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v, c");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_CleStruct));
}
/// Input arguments of an ODE/DAE function
///
/// \copydoc scheme_ControlledDAEInput
template<class M>
IOSchemeVector<M> controldaeIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M()) {
  std::vector<M> ret(9);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ControlledDAEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in ControlledDAEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "t, x, z, p, u, u_interp, x_major, t0, tf");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_ControlledDAEInput));
}
/// Input arguments of a control simulator
///
/// \copydoc scheme_ControlSimulatorInput
template<class M>
IOSchemeVector<M> controlsimulatorIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_ControlSimulatorInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in ControlSimulatorInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x0, p, u");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_ControlSimulatorInput));
}
/// Input arguments of a \e dle solver
///
/// \copydoc scheme_DLEInput
template<class M>
IOSchemeVector<M> dleIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DLEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DLEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DLEInput));
}
/// Output arguments of a \e dle solver
///
/// \copydoc scheme_DLEOutput
template<class M>
IOSchemeVector<M> dleOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DLEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DLEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DLEOutput));
}
/// Input arguments of a \e dple solver
///
/// \copydoc scheme_DPLEInput
template<class M>
IOSchemeVector<M> dpleIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DPLEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DPLEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DPLEInput));
}
/// Output arguments of a \e dple solver
///
/// \copydoc scheme_DPLEOutput
template<class M>
IOSchemeVector<M> dpleOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DPLEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DPLEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DPLEOutput));
}
/// Structure specification of a DPLE
///
/// \copydoc scheme_DpleVecStruct
template<class M>
IOSchemeVector<M> dpleStruct(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DpleVecStruct, it->first);
    if (n==-1)
      casadi_error("Keyword error in DpleVecStruct: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DpleVecStruct));
}
/// Input arguments of an Homotopy NLP function
///
/// \copydoc scheme_HNLPInput
template<class M>
IOSchemeVector<M> hnlpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_HNLPInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in HNLPInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p, tau");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_HNLPInput));
}
/// Input arguments of an ODE/DAE function
///
/// \copydoc scheme_DAEInput
template<class M>
IOSchemeVector<M> daeIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DAEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DAEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, z, p, t");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DAEInput));
}
/// Output arguments of an DAE function
///
/// \copydoc scheme_DAEOutput
template<class M>
IOSchemeVector<M> daeOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_DAEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in DAEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "ode, alg, quad");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_DAEOutput));
}
/// Input arguments of an ODE/DAE backward integration function
///
/// \copydoc scheme_RDAEInput
template<class M>
IOSchemeVector<M> rdaeIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M()) {
  std::vector<M> ret(7);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_RDAEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in RDAEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "rx, rz, rp, x, z, p, t");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_RDAEInput));
}
/// Output arguments of an ODE/DAE backward integration function
///
/// \copydoc scheme_RDAEOutput
template<class M>
IOSchemeVector<M> rdaeOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_RDAEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in RDAEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "ode, alg, quad");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_RDAEOutput));
}
/// Input arguments of an integrator
///
/// \copydoc scheme_IntegratorInput
template<class M>
IOSchemeVector<M> integratorIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M()) {
  std::vector<M> ret(6);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_IntegratorInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in IntegratorInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x0, p, z0, rx0, rp, rz0");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_IntegratorInput));
}
/// Output arguments of an integrator
///
/// \copydoc scheme_IntegratorOutput
template<class M>
IOSchemeVector<M> integratorOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M()) {
  std::vector<M> ret(6);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_IntegratorOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in IntegratorOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "xf, qf, zf, rxf, rqf, rzf");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_IntegratorOutput));
}
/// Input arguments of a linear solver
///
/// \copydoc scheme_LinsolInput
template<class M>
IOSchemeVector<M> linsolIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LinsolInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LinsolInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "A, B");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LinsolInput));
}
/// Output arguments of a linear solver
///
/// \copydoc scheme_LinsolOutput
template<class M>
IOSchemeVector<M> linsolOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LinsolOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LinsolOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "X");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LinsolOutput));
}
/// Input arguments of a LP problem
///
/// \copydoc scheme_LpSolverInput
template<class M>
IOSchemeVector<M> lpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M()) {
  std::vector<M> ret(6);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LpSolverInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LpSolverInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "c, a, lba, uba, lbx, ubx");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LpSolverInput));
}
/// Output arguments of an LP Solver
///
/// \copydoc scheme_LpSolverOutput
template<class M>
IOSchemeVector<M> lpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LpSolverOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LpSolverOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LpSolverOutput));
}
/// Input arguments of a \e dle solver
///
/// \copydoc scheme_LR_DLEInput
template<class M>
IOSchemeVector<M> lrdleIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LR_DLEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LR_DLEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v, c, h");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LR_DLEInput));
}
/// Output arguments of a \e dle solver
///
/// \copydoc scheme_LR_DLEOutput
template<class M>
IOSchemeVector<M> lrdleOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LR_DLEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LR_DLEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "y");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LR_DLEOutput));
}
/// Input arguments of a \e dple solver
///
/// \copydoc scheme_LR_DPLEInput
template<class M>
IOSchemeVector<M> lrdpleIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LR_DPLEInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LR_DPLEInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v, c, h");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LR_DPLEInput));
}
/// Output arguments of a \e dple solver
///
/// \copydoc scheme_LR_DPLEOutput
template<class M>
IOSchemeVector<M> lrdpleOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M()) {
  std::vector<M> ret(1);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LR_DPLEOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in LR_DPLEOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "y");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LR_DPLEOutput));
}
/// Structure specification of a DPLE
///
/// \copydoc scheme_LrDpleVecStruct
template<class M>
IOSchemeVector<M> lrdpleStruct(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_LrDpleVecStruct, it->first);
    if (n==-1)
      casadi_error("Keyword error in LrDpleVecStruct: '" << it->first
        << "' is not recognized. Available keywords are: "
        "a, v, c, h");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_LrDpleVecStruct));
}
/// Input arguments of an NLP function
///
/// \copydoc scheme_NLPInput
template<class M>
IOSchemeVector<M> nlpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_NLPInput));
}
/// Output arguments of an NLP function
///
/// \copydoc scheme_NLPOutput
template<class M>
IOSchemeVector<M> nlpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NLPOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in NLPOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "f, g");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_NLPOutput));
}
/// Input arguments of an NLP objective gradient function
///
/// \copydoc scheme_GradFInput
template<class M>
IOSchemeVector<M> gradFIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_GradFInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in GradFInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_GradFInput));
}
/// Output arguments of an NLP objective gradient function
///
/// \copydoc scheme_GradFOutput
template<class M>
IOSchemeVector<M> gradFOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_GradFOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in GradFOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "grad, f, g");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_GradFOutput));
}
/// Input arguments of an NLP Jacobian function
///
/// \copydoc scheme_JacGInput
template<class M>
IOSchemeVector<M> jacGIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M()) {
  std::vector<M> ret(2);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_JacGInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in JacGInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_JacGInput));
}
/// Output arguments of an NLP Jacobian function
///
/// \copydoc scheme_JacGOutput
template<class M>
IOSchemeVector<M> jacGOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M()) {
  std::vector<M> ret(3);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_JacGOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in JacGOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "jac, f, g");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_JacGOutput));
}
/// Input arguments of an NLP Hessian function
///
/// \copydoc scheme_HessLagInput
template<class M>
IOSchemeVector<M> hessLagIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_HessLagInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in HessLagInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p, lam_f, lam_g");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_HessLagInput));
}
/// Output arguments of an NLP Hessian function
///
/// \copydoc scheme_HessLagOutput
template<class M>
IOSchemeVector<M> hessLagOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M()) {
  std::vector<M> ret(5);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_HessLagOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in HessLagOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "hess, f, g, grad_x, grad_p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_HessLagOutput));
}
/// Input arguments of an NLP Solver
///
/// \copydoc scheme_NlpSolverInput
template<class M>
IOSchemeVector<M> nlpSolverIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M()) {
  std::vector<M> ret(8);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NlpSolverInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in NlpSolverInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_NlpSolverInput));
}
/// Output arguments of an NLP Solver
///
/// \copydoc scheme_NlpSolverOutput
template<class M>
IOSchemeVector<M> nlpSolverOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M()) {
  std::vector<M> ret(6);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_NlpSolverOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in NlpSolverOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, f, g, lam_x, lam_g, lam_p");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_NlpSolverOutput));
}
/// Input arguments of a QP problem
///
/// \copydoc scheme_QcqpSolverInput
template<class M>
IOSchemeVector<M> qcqpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M(),
    const std::string &arg_s9 ="", const M &arg_m9 =M(),
    const std::string &arg_s10 ="", const M &arg_m10 =M(),
    const std::string &arg_s11 ="", const M &arg_m11 =M()) {
  std::vector<M> ret(12);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  if (arg_s9 != "") arg.insert(make_pair(arg_s9, arg_m9));
  if (arg_s10 != "") arg.insert(make_pair(arg_s10, arg_m10));
  if (arg_s11 != "") arg.insert(make_pair(arg_s11, arg_m11));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QcqpSolverInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in QcqpSolverInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "h, g, p, q, r, a, lba, uba, lbx, ubx, x0, lam_x0");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_QcqpSolverInput));
}
/// Output arguments of an QP Solver
///
/// \copydoc scheme_QcqpSolverOutput
template<class M>
IOSchemeVector<M> qcqpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QcqpSolverOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in QcqpSolverOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_QcqpSolverOutput));
}
/// Input arguments of a QP problem
///
/// \copydoc scheme_QpSolverInput
template<class M>
IOSchemeVector<M> qpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M()) {
  std::vector<M> ret(9);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QpSolverInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in QpSolverInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "h, g, a, lba, uba, lbx, ubx, x0, lam_x0");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_QpSolverInput));
}
/// Output arguments of an QP Solver
///
/// \copydoc scheme_QpSolverOutput
template<class M>
IOSchemeVector<M> qpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_QpSolverOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in QpSolverOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_QpSolverOutput));
}
/// Input arguments of a SDP problem
///
/// \copydoc scheme_SDPInput
template<class M>
IOSchemeVector<M> sdpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M()) {
  std::vector<M> ret(8);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDPInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SDPInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "f, c, g, a, lba, uba, lbx, ubx");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SDPInput));
}
/// Output arguments of an SDP Solver
///
/// \copydoc scheme_SDPOutput
template<class M>
IOSchemeVector<M> sdpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M()) {
  std::vector<M> ret(7);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDPOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SDPOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p, dual, cost, dual_cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SDPOutput));
}
/// Input arguments of a SDQP problem
///
/// \copydoc scheme_SDQPInput
template<class M>
IOSchemeVector<M> sdqpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M()) {
  std::vector<M> ret(9);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDQPInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SDQPInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "h, c, f, g, a, lba, uba, lbx, ubx");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SDQPInput));
}
/// Output arguments of an SDQP Solver
///
/// \copydoc scheme_SDQPOutput
template<class M>
IOSchemeVector<M> sdqpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M()) {
  std::vector<M> ret(7);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SDQPOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SDQPOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, p, dual, cost, dual_cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SDQPOutput));
}
/// Input arguments of a SOCP problem
///
/// \copydoc scheme_SOCPInput
template<class M>
IOSchemeVector<M> socpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M(),
    const std::string &arg_s9 ="", const M &arg_m9 =M()) {
  std::vector<M> ret(10);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  if (arg_s9 != "") arg.insert(make_pair(arg_s9, arg_m9));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SOCPInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SOCPInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "g, h, e, f, c, a, lba, uba, lbx, ubx");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SOCPInput));
}
/// Output arguments of an SOCP Solver
///
/// \copydoc scheme_SOCPOutput
template<class M>
IOSchemeVector<M> socpOut(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M()) {
  std::vector<M> ret(4);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_SOCPOutput, it->first);
    if (n==-1)
      casadi_error("Keyword error in SOCPOutput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "x, cost, lam_a, lam_x");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_SOCPOutput));
}
/// Input arguments of a QP problem
///
/// \copydoc scheme_StabilizedQpSolverInput
template<class M>
IOSchemeVector<M> stabilizedQpIn(
    const std::string &arg_s0 ="", const M &arg_m0 =M(),
    const std::string &arg_s1 ="", const M &arg_m1 =M(),
    const std::string &arg_s2 ="", const M &arg_m2 =M(),
    const std::string &arg_s3 ="", const M &arg_m3 =M(),
    const std::string &arg_s4 ="", const M &arg_m4 =M(),
    const std::string &arg_s5 ="", const M &arg_m5 =M(),
    const std::string &arg_s6 ="", const M &arg_m6 =M(),
    const std::string &arg_s7 ="", const M &arg_m7 =M(),
    const std::string &arg_s8 ="", const M &arg_m8 =M(),
    const std::string &arg_s9 ="", const M &arg_m9 =M(),
    const std::string &arg_s10 ="", const M &arg_m10 =M(),
    const std::string &arg_s11 ="", const M &arg_m11 =M()) {
  std::vector<M> ret(12);
  std::map<std::string, M> arg;
  if (arg_s0 != "") arg.insert(make_pair(arg_s0, arg_m0));
  if (arg_s1 != "") arg.insert(make_pair(arg_s1, arg_m1));
  if (arg_s2 != "") arg.insert(make_pair(arg_s2, arg_m2));
  if (arg_s3 != "") arg.insert(make_pair(arg_s3, arg_m3));
  if (arg_s4 != "") arg.insert(make_pair(arg_s4, arg_m4));
  if (arg_s5 != "") arg.insert(make_pair(arg_s5, arg_m5));
  if (arg_s6 != "") arg.insert(make_pair(arg_s6, arg_m6));
  if (arg_s7 != "") arg.insert(make_pair(arg_s7, arg_m7));
  if (arg_s8 != "") arg.insert(make_pair(arg_s8, arg_m8));
  if (arg_s9 != "") arg.insert(make_pair(arg_s9, arg_m9));
  if (arg_s10 != "") arg.insert(make_pair(arg_s10, arg_m10));
  if (arg_s11 != "") arg.insert(make_pair(arg_s11, arg_m11));
  typedef typename std::map<std::string, M>::const_iterator it_type;
  for (it_type it = arg.begin(); it != arg.end(); it++) {
    int n = getSchemeEntryEnum(SCHEME_StabilizedQpSolverInput, it->first);
    if (n==-1)
      casadi_error("Keyword error in StabilizedQpSolverInput: '" << it->first
        << "' is not recognized. Available keywords are: "
        "h, g, a, lba, uba, lbx, ubx, x0, lam_x0, muR, muE, mu");  // NOLINT(whitespace/line_length)
    ret[n] = it->second;
  }
  return IOSchemeVector<M>(ret, IOScheme(SCHEME_StabilizedQpSolverInput));
}
} // namespace casadi
#endif //SCHEMES_HELPERS_HPP

