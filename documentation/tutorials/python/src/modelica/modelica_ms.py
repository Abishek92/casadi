#
#     This file is part of CasADi.
# 
#     CasADi -- A symbolic framework for dynamic optimization.
#     Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
# 
#     CasADi is free software; you can redistribute it and/or
#     modify it under the terms of the GNU Lesser General Public
#     License as published by the Free Software Foundation; either
#     version 3 of the License, or (at your option) any later version.
# 
#     CasADi is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#     Lesser General Public License for more details.
# 
#     You should have received a copy of the GNU Lesser General Public
#     License along with CasADi; if not, write to the Free Software
#     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
# 
# 
#! Direct multiple shooting with CasADi and JModelica.org
#! ==================
#! To implement an optimal control solver for a Modelica model, let us begin by 
#! retrieving the model equations from an FMUX object generated by JModelica.org.
#! For this we extract the file modelDescription.xml from FMUX file as follows:
import zipfile
import os
curr_dir = os.path.dirname(os.path.abspath(__file__))
fmux = zipfile.ZipFile(curr_dir+"/CSTR_CSTR_Opt2.fmux",'r')
fmux.extract('modelDescription.xml','.')
#! This file can be imported into CasADi, building up a symbolic representation of the model
#! The logic for importing Modelica models is located in the SymbolicOCP class:
from casadi import *
ocp = SymbolicOCP()
parse_options = {"eliminate_dependent":True}
ocp.parseFMI("modelDescription.xml",parse_options)
#! Let us have a look at the flat optimal control problem:
print ocp
#! As we see, the optimal control problem (OCP) has two differential states (cstr.c and cstr.T),
#! two algebraic variables (cstr.Tc and q) and one free control.
#! By insprecting the equations, we see that it is relatively both straightforward to eliminate 
#! the algebraic variables from the problem and to rewrite the DAE as an explicit ODE.
#! Indeed, for cases like this one, CasADi can do this reformulation automatically:
ocp.eliminateAlgebraic()
ocp.makeExplicit()
#! Let us extract variables for the states, the control and equations
x = SX(var(ocp.x))  # Differential states
u = SX(var(ocp.u))  # Free controls
f = ocp.ode         # ODE right hand side
L = ocp.lterm       # Integral term in the objective
I = ocp.initial     # Initial equations
#! These are expressions that can be visualized or manipulated using CasADi's 
#! symbolic framework:
print 5*sin(f[0])
print jacobian(f,x)
print gradient(L,x)
#! We can also retrieve other information from the model such as the end time,
#! variable bounds and initial guess:
tf = ocp.tf
ubx = getMax(ocp.x)
lbx = getMin(ocp.x)
ubu = getMax(ocp.u)
lbu = getMin(ocp.u)
x0 = getInitialGuess(ocp.x)
u0 = getInitialGuess(ocp.u)
#! The optimal control problem we wish to solve it:
#!    minimize    \int_{t=0}^{tf}{L(t) dt}
#!    subject to  I(x) = 0,   t == 0
#!                dot(x) = f, 0 <= t <= tf
#!                lbx <= x <= ubx,   lbu <= u <= ubu, 0 <= t <= tf
#! with
print "f = ", f
print "I = ", I
print "L = ", L
print "lbx = ", lbx
print "ubx = ", ubx
print "lbu = ", lbu
print "ubu = ", ubu
#! From the symbolic expressions, we can create functions (functors) for evaluating the 
#! ODE right hand side numerically or symbolically. The following code creates a function
#! with two inputs (x and u) and two outputs (f and L):
ode_fcn = SXFunction([x,u],[f,L]) # R^2 x R --> R^2 x R
ode_fcn.setOption("name","ode_fcn") # Shows up in printing
ode_fcn.init()
#! We also create a function for evaluating the initial conditions:
init_fcn = SXFunction([x],[I])
init_fcn.setOption("name","init_fcn")
init_fcn.init()
#! With the ODE given, we are now ready to formulate the NLP
#! We shall use the "direct multiple shooting" method with 20 shooting intervals of equal length.
#! On each of these interval we shall assume that the control remains constant:
nk = 20
dt = tf/nk
#! In the direct multiple shooting method, the control parametrization and the state
#! at the beginning of each interval are degrees of freedom in the NLP.
#! Since we have one control and two states and we have nk intervals, there are in total 3*nk intervals.
#! Let us declare a vector-valued CasADi symbolic primitive corresponding to these degrees of freedom:
v = MX.sym("v",3*nk)
#! Next, we split up this 3*nk-by-1 matrix vertically int nk vectors of length 3 and then get expressions
#! for the state and control for each interval:
vk = vertsplit(v,3)
xk = [i[:2] for i in vk]
uk = [i[2]  for i in vk]
#! We are now ready to construct the NLP. We begin by getting expressions for the upper and lower bounds
#! of the decision variable as well as an initial guess:
lbv = (lbx + lbu) * nk
ubv = (ubx + ubu) * nk
v0 = (x0 + u0) * nk
#! Next, let us build up expressions for the objective (cost) function and the nonlinear constraints:
J = 0   # Objective
eq = [] # Constraints
#! We begin by adding to the NLP, the equations corresponding to the initial conditions. For this we
#! "call" the above created init_fcn with the expression for the state at the first interval:
[eq0] = init_fcn.call([xk[0]])
eq.append(eq0)
#! Next, we loop over the shooting intervals
for k in range(nk):
    #! Retrieve the value of the state at the beginning of the interval
    xkj = xk[k]
    #! We will integrate with a RK4 integrator with 10 steps
    nj = 10
    h = dt/nj
    for j in range(nj):
        #! k1
        [k1,k1_L] = ode_fcn.call([xkj,uk[k]])
        #! k2
        [k2,k2_L] = ode_fcn.call([xkj + h/2*k1,uk[k]]) 
        #! k3
        [k3,k3_L] = ode_fcn.call([xkj + h/2*k2,uk[k]])
        #! k4
        [k4,k4_L] = ode_fcn.call([xkj + h*k3,uk[k]])
        #! Take the step
        xkj += h/6 * (k1 + 2*k2 + 2*k3 + k4)
        #! Add contribution to the objective function
        J += h/6 * (k1_L + 2*k2_L + 2*k3_L + k4_L)
    #! Inpose the continuity constraint between from one shooting node to the next
    if k+1<nk: eq.append(xkj - xk[k+1])

#! Now form the NLP callback function
nlp = MXFunction(nlpIn(x=v),nlpOut(f=J,g=vertcat(eq)))
#! Create an NLP solver
solver = IpoptSolver(nlp)
solver.init()
#! Pass bounds on the variables and constraints
solver.setInput(lbv,"lbx")
solver.setInput(ubv,"ubx")
solver.setInput(v0,"x0")
solver.setInput(0,"lbg") # Equality constraints, upper and lower bounds zero
solver.setInput(0,"ubg")
#! Solve the NLP
solver.solve()
#! Retrieve the solution
v_opt  = solver.getOutput("x")
x0_opt = v_opt[::3]
x1_opt = v_opt[1::3]
u_opt  = v_opt[2::3]
#! Time grid
import numpy as NP
tgrid = NP.linspace(0,tf,nk)
#! Visualize the solution
import matplotlib.pyplot as plt
plt.figure(1)
plt.clf()
plt.subplot(1,3,1)
plt.plot(tgrid,x0_opt)
plt.title(str(x[0]))
plt.grid()
plt.subplot(1,3,2)
plt.plot(tgrid,x1_opt)
plt.title(str(x[1]))
plt.grid()
plt.subplot(1,3,3)
plt.step(tgrid,u_opt)
plt.title(str(u))
plt.grid()
plt.show()



