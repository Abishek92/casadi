/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef AUTOGENERATED_I
#define AUTOGENERATED_I
%include "casadi/core/function/schemes_metadata.hpp"
%include "casadi/core/function/schemes_helpers.hpp"
#ifdef SWIGPYTHON
%pythoncode %{
def cleIn(**kwargs):
  """
  Helper function for 'CLEInput'

  Usage:
    arg = cleIn(a=my_a, v=my_v)
        all arguments optional
  Input arguments of a \e cle solver
  
  Keyword arguments::

    a -- A matrix [CLE_A]
    v -- V matrix [CLE_V]
  """
  for k in kwargs.keys():
    if k not in ['a', 'v']:
      raise Exception("Error in 'cleIn' arguments. You supplied key '%s'. Allowed keys are: 'a', 'v'" % k)
  return (kwargs, ['a', 'v'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(cleIn) cleIn<casadi::SX>;
%template(cleIn) cleIn<casadi::MX>;
%template(cleIn) cleIn<casadi::Matrix<double> >;
%template(cleIn) cleIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def cleOut(**kwargs):
  """
  Helper function for 'CLEOutput'

  Usage:
    arg = cleOut(p=my_p)
        all arguments optional
  Output arguments of a \e cle solver
  
  Keyword arguments::

    p -- Lyapunov matrix [CLE_P]
  """
  for k in kwargs.keys():
    if k not in ['p']:
      raise Exception("Error in 'cleOut' arguments. You supplied key '%s'. Allowed keys are: 'p'" % k)
  return (kwargs, ['p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(cleOut) cleOut<casadi::SX>;
%template(cleOut) cleOut<casadi::MX>;
%template(cleOut) cleOut<casadi::Matrix<double> >;
%template(cleOut) cleOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def controldaeIn(**kwargs):
  """
  Helper function for 'ControlledDAEInput'

  Usage:
    arg = controldaeIn(t=my_t, x=my_x, z=my_z, p=my_p, u=my_u, u_interp=my_u_interp, x_major=my_x_major, t0=my_t0, tf=my_tf)
        all arguments optional
  Input arguments of an ODE/DAE function
  
  Keyword arguments::

    t        -- Global physical time. (1-by-1) [CONTROL_DAE_T]
    x        -- non-zeros as DAEOutput:DAE_RES [CONTROL_DAE_X]
    z        -- Algebraic state vector (dimension np-by-1). [CONTROL_DAE_Z]
    p        -- Parameter vector (dimension np-by-1). [CONTROL_DAE_P]
    u        -- Control vector (dimension nu-by-1). [CONTROL_DAE_U]
    u_interp -- Control vector, linearly interpolated (dimension nu-by-1). [CONTROL_DAE_U_INTERP]
    x_major  -- State vector (dimension nx-by-1) at the last major time-step [CONTROL_DAE_X_MAJOR]
    t0       -- Time at start of control interval (1-by-1) [CONTROL_DAE_T0]
    tf       -- Time at end of control interval (1-by-1) [CONTROL_DAE_TF]
  """
  for k in kwargs.keys():
    if k not in ['t', 'x', 'z', 'p', 'u', 'u_interp', 'x_major', 't0', 'tf']:
      raise Exception("Error in 'controldaeIn' arguments. You supplied key '%s'. Allowed keys are: 't', 'x', 'z', 'p', 'u', 'u_interp', 'x_major', 't0', 'tf'" % k)
  return (kwargs, ['t', 'x', 'z', 'p', 'u', 'u_interp', 'x_major', 't0', 'tf'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(controldaeIn) controldaeIn<casadi::SX>;
%template(controldaeIn) controldaeIn<casadi::MX>;
%template(controldaeIn) controldaeIn<casadi::Matrix<double> >;
%template(controldaeIn) controldaeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def controlsimulatorIn(**kwargs):
  """
  Helper function for 'ControlSimulatorInput'

  Usage:
    arg = controlsimulatorIn(x0=my_x0, p=my_p, u=my_u)
        all arguments optional
  Input arguments of a control simulator
  
  Keyword arguments::

    x0 -- Differential or algebraic state at t0  (dimension nx-by-1) [CONTROLSIMULATOR_X0]
    p  -- Parameters that are fixed over the entire horizon  (dimension np-by-1) [CONTROLSIMULATOR_P]
    u  -- Parameters that change over the integration intervals (dimension nu-by-(ns-1)) [CONTROLSIMULATOR_U]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'u']:
      raise Exception("Error in 'controlsimulatorIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'u'" % k)
  return (kwargs, ['x0', 'p', 'u'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(controlsimulatorIn) controlsimulatorIn<casadi::SX>;
%template(controlsimulatorIn) controlsimulatorIn<casadi::MX>;
%template(controlsimulatorIn) controlsimulatorIn<casadi::Matrix<double> >;
%template(controlsimulatorIn) controlsimulatorIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def dleIn(**kwargs):
  """
  Helper function for 'DLEInput'

  Usage:
    arg = dleIn(a=my_a, v=my_v)
        all arguments optional
  Input arguments of a \e dle solver
  
  Keyword arguments::

    a -- A matrix [DLE_A]
    v -- V matrix [DLE_V]
  """
  for k in kwargs.keys():
    if k not in ['a', 'v']:
      raise Exception("Error in 'dleIn' arguments. You supplied key '%s'. Allowed keys are: 'a', 'v'" % k)
  return (kwargs, ['a', 'v'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(dleIn) dleIn<casadi::SX>;
%template(dleIn) dleIn<casadi::MX>;
%template(dleIn) dleIn<casadi::Matrix<double> >;
%template(dleIn) dleIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def dleOut(**kwargs):
  """
  Helper function for 'DLEOutput'

  Usage:
    arg = dleOut(p=my_p)
        all arguments optional
  Output arguments of a \e dle solver
  
  Keyword arguments::

    p -- P matrix [DLE_P]
  """
  for k in kwargs.keys():
    if k not in ['p']:
      raise Exception("Error in 'dleOut' arguments. You supplied key '%s'. Allowed keys are: 'p'" % k)
  return (kwargs, ['p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(dleOut) dleOut<casadi::SX>;
%template(dleOut) dleOut<casadi::MX>;
%template(dleOut) dleOut<casadi::Matrix<double> >;
%template(dleOut) dleOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def dpleIn(**kwargs):
  """
  Helper function for 'DPLEInput'

  Usage:
    arg = dpleIn(a=my_a, v=my_v)
        all arguments optional
  Input arguments of a \e dple solver
  
  Keyword arguments::

    a -- A matrices (horzcat when const_dim, diagcat otherwise) [DPLE_A]
    v -- V matrices (horzcat when const_dim, diagcat otherwise) [DPLE_V]
  """
  for k in kwargs.keys():
    if k not in ['a', 'v']:
      raise Exception("Error in 'dpleIn' arguments. You supplied key '%s'. Allowed keys are: 'a', 'v'" % k)
  return (kwargs, ['a', 'v'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(dpleIn) dpleIn<casadi::SX>;
%template(dpleIn) dpleIn<casadi::MX>;
%template(dpleIn) dpleIn<casadi::Matrix<double> >;
%template(dpleIn) dpleIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def dpleOut(**kwargs):
  """
  Helper function for 'DPLEOutput'

  Usage:
    arg = dpleOut(p=my_p)
        all arguments optional
  Output arguments of a \e dple solver
  
  Keyword arguments::

    p -- Lyapunov matrix (horzcat when const_dim, diagcat otherwise) (Cholesky of P if pos_def) [DPLE_P]
  """
  for k in kwargs.keys():
    if k not in ['p']:
      raise Exception("Error in 'dpleOut' arguments. You supplied key '%s'. Allowed keys are: 'p'" % k)
  return (kwargs, ['p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(dpleOut) dpleOut<casadi::SX>;
%template(dpleOut) dpleOut<casadi::MX>;
%template(dpleOut) dpleOut<casadi::Matrix<double> >;
%template(dpleOut) dpleOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hnlpIn(**kwargs):
  """
  Helper function for 'HNLPInput'

  Usage:
    arg = hnlpIn(x=my_x, p=my_p, tau=my_tau)
        all arguments optional
  Input arguments of an Homotopy NLP function
  
  Keyword arguments::

    x   -- Decision variable [HNL_X]
    p   -- Fixed parameter [HNL_P]
    tau -- Homotopy parameter [HNL_TAU]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'tau']:
      raise Exception("Error in 'hnlpIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'tau'" % k)
  return (kwargs, ['x', 'p', 'tau'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hnlpIn) hnlpIn<casadi::SX>;
%template(hnlpIn) hnlpIn<casadi::MX>;
%template(hnlpIn) hnlpIn<casadi::Matrix<double> >;
%template(hnlpIn) hnlpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeIn(**kwargs):
  """
  Helper function for 'DAEInput'

  Usage:
    arg = daeIn(x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE function
  
  Keyword arguments::

    x -- Differential state [DAE_X]
    z -- Algebraic state [DAE_Z]
    p -- Parameter [DAE_P]
    t -- Explicit time dependence [DAE_T]
  """
  for k in kwargs.keys():
    if k not in ['x', 'z', 'p', 't']:
      raise Exception("Error in 'daeIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeIn) daeIn<casadi::SX>;
%template(daeIn) daeIn<casadi::MX>;
%template(daeIn) daeIn<casadi::Matrix<double> >;
%template(daeIn) daeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeOut(**kwargs):
  """
  Helper function for 'DAEOutput'

  Usage:
    arg = daeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an DAE function
  
  Keyword arguments::

    ode  -- Right hand side of the implicit ODE [DAE_ODE]
    alg  -- Right hand side of algebraic equations [DAE_ALG]
    quad -- Right hand side of quadratures equations [DAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'daeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeOut) daeOut<casadi::SX>;
%template(daeOut) daeOut<casadi::MX>;
%template(daeOut) daeOut<casadi::Matrix<double> >;
%template(daeOut) daeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeIn(**kwargs):
  """
  Helper function for 'RDAEInput'

  Usage:
    arg = rdaeIn(rx=my_rx, rz=my_rz, rp=my_rp, x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    rx -- Backward differential state [RDAE_RX]
    rz -- Backward algebraic state [RDAE_RZ]
    rp -- Backward  parameter vector [RDAE_RP]
    x  -- Forward differential state [RDAE_X]
    z  -- Forward algebraic state [RDAE_Z]
    p  -- Parameter vector [RDAE_P]
    t  -- Explicit time dependence [RDAE_T]
  """
  for k in kwargs.keys():
    if k not in ['rx', 'rz', 'rp', 'x', 'z', 'p', 't']:
      raise Exception("Error in 'rdaeIn' arguments. You supplied key '%s'. Allowed keys are: 'rx', 'rz', 'rp', 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['rx', 'rz', 'rp', 'x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeIn) rdaeIn<casadi::SX>;
%template(rdaeIn) rdaeIn<casadi::MX>;
%template(rdaeIn) rdaeIn<casadi::Matrix<double> >;
%template(rdaeIn) rdaeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeOut(**kwargs):
  """
  Helper function for 'RDAEOutput'

  Usage:
    arg = rdaeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    ode  -- Right hand side of ODE. [RDAE_ODE]
    alg  -- Right hand side of algebraic equations. [RDAE_ALG]
    quad -- Right hand side of quadratures. [RDAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'rdaeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeOut) rdaeOut<casadi::SX>;
%template(rdaeOut) rdaeOut<casadi::MX>;
%template(rdaeOut) rdaeOut<casadi::Matrix<double> >;
%template(rdaeOut) rdaeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorIn(**kwargs):
  """
  Helper function for 'IntegratorInput'

  Usage:
    arg = integratorIn(x0=my_x0, p=my_p, z0=my_z0, rx0=my_rx0, rp=my_rp, rz0=my_rz0)
        all arguments optional
  Input arguments of an integrator
  
  Keyword arguments::

    x0  -- Differential state at the initial time [INTEGRATOR_X0]
    p   -- Parameters [INTEGRATOR_P]
    z0  -- Initial guess for the algebraic variable [INTEGRATOR_Z0]
    rx0 -- Backward differential state at the final time [INTEGRATOR_RX0]
    rp  -- Backward parameter vector [INTEGRATOR_RP]
    rz0 -- Initial guess for the backwards algebraic variable [INTEGRATOR_RZ0]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0']:
      raise Exception("Error in 'integratorIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'z0', 'rx0', 'rp', 'rz0'" % k)
  return (kwargs, ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorIn) integratorIn<casadi::SX>;
%template(integratorIn) integratorIn<casadi::MX>;
%template(integratorIn) integratorIn<casadi::Matrix<double> >;
%template(integratorIn) integratorIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorOut(**kwargs):
  """
  Helper function for 'IntegratorOutput'

  Usage:
    arg = integratorOut(xf=my_xf, qf=my_qf, zf=my_zf, rxf=my_rxf, rqf=my_rqf, rzf=my_rzf)
        all arguments optional
  Output arguments of an integrator
  
  Keyword arguments::

    xf  -- Differential state at the final time [INTEGRATOR_XF]
    qf  -- Quadrature state at the final time [INTEGRATOR_QF]
    zf  -- Algebraic variable at the final time [INTEGRATOR_ZF]
    rxf -- Backward differential state at the initial time [INTEGRATOR_RXF]
    rqf -- Backward quadrature state at the initial time [INTEGRATOR_RQF]
    rzf -- Backward algebraic variable at the initial time [INTEGRATOR_RZF]
  """
  for k in kwargs.keys():
    if k not in ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf']:
      raise Exception("Error in 'integratorOut' arguments. You supplied key '%s'. Allowed keys are: 'xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'" % k)
  return (kwargs, ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorOut) integratorOut<casadi::SX>;
%template(integratorOut) integratorOut<casadi::MX>;
%template(integratorOut) integratorOut<casadi::Matrix<double> >;
%template(integratorOut) integratorOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolIn(**kwargs):
  """
  Helper function for 'LinsolInput'

  Usage:
    arg = linsolIn(A=my_A, B=my_B)
        all arguments optional
  Input arguments of a linear solver
  
  Keyword arguments::

    A -- The square matrix A: sparse, (n x n). [LINSOL_A]
    B -- The right-hand-side matrix b: dense,  (n x m) [LINSOL_B]
  """
  for k in kwargs.keys():
    if k not in ['A', 'B']:
      raise Exception("Error in 'linsolIn' arguments. You supplied key '%s'. Allowed keys are: 'A', 'B'" % k)
  return (kwargs, ['A', 'B'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolIn) linsolIn<casadi::SX>;
%template(linsolIn) linsolIn<casadi::MX>;
%template(linsolIn) linsolIn<casadi::Matrix<double> >;
%template(linsolIn) linsolIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolOut(**kwargs):
  """
  Helper function for 'LinsolOutput'

  Usage:
    arg = linsolOut(X=my_X)
        all arguments optional
  Output arguments of a linear solver
  
  Keyword arguments::

    X -- Solution to the linear system of equations [LINSOL_X]
  """
  for k in kwargs.keys():
    if k not in ['X']:
      raise Exception("Error in 'linsolOut' arguments. You supplied key '%s'. Allowed keys are: 'X'" % k)
  return (kwargs, ['X'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolOut) linsolOut<casadi::SX>;
%template(linsolOut) linsolOut<casadi::MX>;
%template(linsolOut) linsolOut<casadi::Matrix<double> >;
%template(linsolOut) linsolOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lpIn(**kwargs):
  """
  Helper function for 'LpSolverInput'

  Usage:
    arg = lpIn(c=my_c, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
        all arguments optional
  Input arguments of a LP problem
  
  Keyword arguments::

    c   -- The vector c: dense (n x 1) [LP_SOLVER_C]
    a   -- The matrix A: sparse, (nc x n) - product with x must be dense. [LP_SOLVER_A]
    lba -- dense, (nc x 1) [LP_SOLVER_LBA]
    uba -- dense, (nc x 1) [LP_SOLVER_UBA]
    lbx -- dense, (n x 1) [LP_SOLVER_LBX]
    ubx -- dense, (n x 1) [LP_SOLVER_UBX]
  """
  for k in kwargs.keys():
    if k not in ['c', 'a', 'lba', 'uba', 'lbx', 'ubx']:
      raise Exception("Error in 'lpIn' arguments. You supplied key '%s'. Allowed keys are: 'c', 'a', 'lba', 'uba', 'lbx', 'ubx'" % k)
  return (kwargs, ['c', 'a', 'lba', 'uba', 'lbx', 'ubx'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lpIn) lpIn<casadi::SX>;
%template(lpIn) lpIn<casadi::MX>;
%template(lpIn) lpIn<casadi::Matrix<double> >;
%template(lpIn) lpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lpOut(**kwargs):
  """
  Helper function for 'LpSolverOutput'

  Usage:
    arg = lpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an LP Solver
  
  Keyword arguments::

    x     -- The primal solution [LP_SOLVER_X]
    cost  -- The optimal cost [LP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [LP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [LP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'lpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lpOut) lpOut<casadi::SX>;
%template(lpOut) lpOut<casadi::MX>;
%template(lpOut) lpOut<casadi::Matrix<double> >;
%template(lpOut) lpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lrdleIn(**kwargs):
  """
  Helper function for 'LR_DLEInput'

  Usage:
    arg = lrdleIn(a=my_a, v=my_v, c=my_c, h=my_h)
        all arguments optional
  Input arguments of a \e dle solver
  
  Keyword arguments::

    a -- A matrix [LR_DLE_A]
    v -- V matrix [LR_DLE_V]
    c -- C matrix [LR_DLE_C]
    h -- H matrix: horizontal stack of all Hi [LR_DLE_H]
  """
  for k in kwargs.keys():
    if k not in ['a', 'v', 'c', 'h']:
      raise Exception("Error in 'lrdleIn' arguments. You supplied key '%s'. Allowed keys are: 'a', 'v', 'c', 'h'" % k)
  return (kwargs, ['a', 'v', 'c', 'h'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lrdleIn) lrdleIn<casadi::SX>;
%template(lrdleIn) lrdleIn<casadi::MX>;
%template(lrdleIn) lrdleIn<casadi::Matrix<double> >;
%template(lrdleIn) lrdleIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lrdleOut(**kwargs):
  """
  Helper function for 'LR_DLEOutput'

  Usage:
    arg = lrdleOut(y=my_y)
        all arguments optional
  Output arguments of a \e dle solver
  
  Keyword arguments::

    y -- Y matrix, block diagonal form [LR_DLE_Y]
  """
  for k in kwargs.keys():
    if k not in ['y']:
      raise Exception("Error in 'lrdleOut' arguments. You supplied key '%s'. Allowed keys are: 'y'" % k)
  return (kwargs, ['y'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lrdleOut) lrdleOut<casadi::SX>;
%template(lrdleOut) lrdleOut<casadi::MX>;
%template(lrdleOut) lrdleOut<casadi::Matrix<double> >;
%template(lrdleOut) lrdleOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lrdpleIn(**kwargs):
  """
  Helper function for 'LR_DPLEInput'

  Usage:
    arg = lrdpleIn(a=my_a, v=my_v, c=my_c, h=my_h)
        all arguments optional
  Input arguments of a \e dple solver
  
  Keyword arguments::

    a -- A matrices (horzcat when const_dim, diagcat otherwise) [LR_DPLE_A]
    v -- V matrices (horzcat when const_dim, diagcat otherwise) [LR_DPLE_V]
    c -- C matrix [LR_DPLE_C]
    h -- H matrix: horizontal stack of all Hi [LR_DPLE_H]
  """
  for k in kwargs.keys():
    if k not in ['a', 'v', 'c', 'h']:
      raise Exception("Error in 'lrdpleIn' arguments. You supplied key '%s'. Allowed keys are: 'a', 'v', 'c', 'h'" % k)
  return (kwargs, ['a', 'v', 'c', 'h'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lrdpleIn) lrdpleIn<casadi::SX>;
%template(lrdpleIn) lrdpleIn<casadi::MX>;
%template(lrdpleIn) lrdpleIn<casadi::Matrix<double> >;
%template(lrdpleIn) lrdpleIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def lrdpleOut(**kwargs):
  """
  Helper function for 'LR_DPLEOutput'

  Usage:
    arg = lrdpleOut(y=my_y)
        all arguments optional
  Output arguments of a \e dple solver
  
  Keyword arguments::

    y -- Lyapunov matrix (horzcat when const_dim, diagcat otherwise) (Cholesky of P if pos_def) [LR_DPLE_Y]
  """
  for k in kwargs.keys():
    if k not in ['y']:
      raise Exception("Error in 'lrdpleOut' arguments. You supplied key '%s'. Allowed keys are: 'y'" % k)
  return (kwargs, ['y'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(lrdpleOut) lrdpleOut<casadi::SX>;
%template(lrdpleOut) lrdpleOut<casadi::MX>;
%template(lrdpleOut) lrdpleOut<casadi::Matrix<double> >;
%template(lrdpleOut) lrdpleOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpIn(**kwargs):
  """
  Helper function for 'NLPInput'

  Usage:
    arg = nlpIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP function
  
  Keyword arguments::

    x -- Decision variable [NL_X]
    p -- Fixed parameter [NL_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'nlpIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpIn) nlpIn<casadi::SX>;
%template(nlpIn) nlpIn<casadi::MX>;
%template(nlpIn) nlpIn<casadi::Matrix<double> >;
%template(nlpIn) nlpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpOut(**kwargs):
  """
  Helper function for 'NLPOutput'

  Usage:
    arg = nlpOut(f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP function
  
  Keyword arguments::

    f -- Objective function [NL_F]
    g -- Constraint function [NL_G]
  """
  for k in kwargs.keys():
    if k not in ['f', 'g']:
      raise Exception("Error in 'nlpOut' arguments. You supplied key '%s'. Allowed keys are: 'f', 'g'" % k)
  return (kwargs, ['f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpOut) nlpOut<casadi::SX>;
%template(nlpOut) nlpOut<casadi::MX>;
%template(nlpOut) nlpOut<casadi::Matrix<double> >;
%template(nlpOut) nlpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFIn(**kwargs):
  """
  Helper function for 'GradFInput'

  Usage:
    arg = gradFIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP objective gradient function
  
  Keyword arguments::

    x -- Decision variable [GRADF_X]
    p -- Fixed parameter [GRADF_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'gradFIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFIn) gradFIn<casadi::SX>;
%template(gradFIn) gradFIn<casadi::MX>;
%template(gradFIn) gradFIn<casadi::Matrix<double> >;
%template(gradFIn) gradFIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFOut(**kwargs):
  """
  Helper function for 'GradFOutput'

  Usage:
    arg = gradFOut(grad=my_grad, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP objective gradient function
  
  Keyword arguments::

    grad -- Jacobian of the constraints [GRADF_GRAD]
    f    -- Objective function [GRADF_F]
    g    -- Constraint function [GRADF_G]
  """
  for k in kwargs.keys():
    if k not in ['grad', 'f', 'g']:
      raise Exception("Error in 'gradFOut' arguments. You supplied key '%s'. Allowed keys are: 'grad', 'f', 'g'" % k)
  return (kwargs, ['grad', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFOut) gradFOut<casadi::SX>;
%template(gradFOut) gradFOut<casadi::MX>;
%template(gradFOut) gradFOut<casadi::Matrix<double> >;
%template(gradFOut) gradFOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGIn(**kwargs):
  """
  Helper function for 'JacGInput'

  Usage:
    arg = jacGIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP Jacobian function
  
  Keyword arguments::

    x -- Decision variable [JACG_X]
    p -- Fixed parameter [JACG_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'jacGIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGIn) jacGIn<casadi::SX>;
%template(jacGIn) jacGIn<casadi::MX>;
%template(jacGIn) jacGIn<casadi::Matrix<double> >;
%template(jacGIn) jacGIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGOut(**kwargs):
  """
  Helper function for 'JacGOutput'

  Usage:
    arg = jacGOut(jac=my_jac, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP Jacobian function
  
  Keyword arguments::

    jac -- Jacobian of the constraints [JACG_JAC]
    f   -- Objective function [JACG_F]
    g   -- Constraint function [JACG_G]
  """
  for k in kwargs.keys():
    if k not in ['jac', 'f', 'g']:
      raise Exception("Error in 'jacGOut' arguments. You supplied key '%s'. Allowed keys are: 'jac', 'f', 'g'" % k)
  return (kwargs, ['jac', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGOut) jacGOut<casadi::SX>;
%template(jacGOut) jacGOut<casadi::MX>;
%template(jacGOut) jacGOut<casadi::Matrix<double> >;
%template(jacGOut) jacGOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hessLagIn(**kwargs):
  """
  Helper function for 'HessLagInput'

  Usage:
    arg = hessLagIn(x=my_x, p=my_p, lam_f=my_lam_f, lam_g=my_lam_g)
        all arguments optional
  Input arguments of an NLP Hessian function
  
  Keyword arguments::

    x     -- Decision variable [HESSLAG_X]
    p     -- Fixed parameter [HESSLAG_P]
    lam_f -- NLP solver might use to scale the objective. [HESSLAG_LAM_F]
    lam_g -- Multiplier for g [HESSLAG_LAM_G]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'lam_f', 'lam_g']:
      raise Exception("Error in 'hessLagIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'lam_f', 'lam_g'" % k)
  return (kwargs, ['x', 'p', 'lam_f', 'lam_g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hessLagIn) hessLagIn<casadi::SX>;
%template(hessLagIn) hessLagIn<casadi::MX>;
%template(hessLagIn) hessLagIn<casadi::Matrix<double> >;
%template(hessLagIn) hessLagIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hessLagOut(**kwargs):
  """
  Helper function for 'HessLagOutput'

  Usage:
    arg = hessLagOut(hess=my_hess, f=my_f, g=my_g, grad_x=my_grad_x, grad_p=my_grad_p)
        all arguments optional
  Output arguments of an NLP Hessian function
  
  Keyword arguments::

    hess   -- Hessian of the Lagrangian [HESSLAG_HESS]
    f      -- Objective function [HESSLAG_F]
    g      -- Constraint function [HESSLAG_G]
    grad_x -- Gradient of the Lagrangian with respect to x [HESSLAG_GRAD_X]
    grad_p -- Gradient of the Lagrangian with respect to p [HESSLAG_GRAD_P]
  """
  for k in kwargs.keys():
    if k not in ['hess', 'f', 'g', 'grad_x', 'grad_p']:
      raise Exception("Error in 'hessLagOut' arguments. You supplied key '%s'. Allowed keys are: 'hess', 'f', 'g', 'grad_x', 'grad_p'" % k)
  return (kwargs, ['hess', 'f', 'g', 'grad_x', 'grad_p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hessLagOut) hessLagOut<casadi::SX>;
%template(hessLagOut) hessLagOut<casadi::MX>;
%template(hessLagOut) hessLagOut<casadi::Matrix<double> >;
%template(hessLagOut) hessLagOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpSolverIn(**kwargs):
  """
  Helper function for 'NlpSolverInput'

  Usage:
    arg = nlpSolverIn(x0=my_x0, p=my_p, lbx=my_lbx, ubx=my_ubx, lbg=my_lbg, ubg=my_ubg, lam_x0=my_lam_x0, lam_g0=my_lam_g0)
        all arguments optional
  Input arguments of an NLP Solver
  
  Keyword arguments::

    x0     -- Decision variables, initial guess (nx x 1)  [NLP_SOLVER_X0]
    p      -- Value of fixed parameters (np x 1) [NLP_SOLVER_P]
    lbx    -- Decision variables lower bound (nx x 1), default -inf [NLP_SOLVER_LBX]
    ubx    -- Decision variables upper bound (nx x 1), default +inf [NLP_SOLVER_UBX]
    lbg    -- Constraints lower bound (ng x 1), default -inf [NLP_SOLVER_LBG]
    ubg    -- Constraints upper bound (ng x 1), default +inf [NLP_SOLVER_UBG]
    lam_x0 -- Lagrange multipliers for bounds on X, initial guess (nx x 1) [NLP_SOLVER_LAM_X0]
    lam_g0 -- Lagrange multipliers for bounds on G, initial guess (ng x 1) [NLP_SOLVER_LAM_G0]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0']:
      raise Exception("Error in 'nlpSolverIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0'" % k)
  return (kwargs, ['x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpSolverIn) nlpSolverIn<casadi::SX>;
%template(nlpSolverIn) nlpSolverIn<casadi::MX>;
%template(nlpSolverIn) nlpSolverIn<casadi::Matrix<double> >;
%template(nlpSolverIn) nlpSolverIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpSolverOut(**kwargs):
  """
  Helper function for 'NlpSolverOutput'

  Usage:
    arg = nlpSolverOut(x=my_x, f=my_f, g=my_g, lam_x=my_lam_x, lam_g=my_lam_g, lam_p=my_lam_p)
        all arguments optional
  Output arguments of an NLP Solver
  
  Keyword arguments::

    x     -- Decision variables at the optimal solution (nx x 1) [NLP_SOLVER_X]
    f     -- Cost function value at the optimal solution (1 x 1) [NLP_SOLVER_F]
    g     -- Constraints function at the optimal solution (ng x 1) [NLP_SOLVER_G]
    lam_x -- Lagrange multipliers for bounds on X at the solution (nx x 1) [NLP_SOLVER_LAM_X]
    lam_g -- Lagrange multipliers for bounds on G at the solution (ng x 1) [NLP_SOLVER_LAM_G]
    lam_p -- Lagrange multipliers for bounds on P at the solution (np x 1) [NLP_SOLVER_LAM_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p']:
      raise Exception("Error in 'nlpSolverOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'" % k)
  return (kwargs, ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpSolverOut) nlpSolverOut<casadi::SX>;
%template(nlpSolverOut) nlpSolverOut<casadi::MX>;
%template(nlpSolverOut) nlpSolverOut<casadi::Matrix<double> >;
%template(nlpSolverOut) nlpSolverOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qcqpIn(**kwargs):
  """
  Helper function for 'QcqpSolverInput'

  Usage:
    arg = qcqpIn(h=my_h, g=my_g, p=my_p, q=my_q, r=my_r, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0)
        all arguments optional
  Input arguments of a QP problem
  
  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [QCQP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [QCQP_SOLVER_G]
    p      -- triangular part is actually used. The matrix is assumed to be symmetrical. [QCQP_SOLVER_P]
    q      -- The vertical stack of all qi: dense,  (nq n x 1) [QCQP_SOLVER_Q]
    r      -- The vertical stack of all scalars ri (nq x 1)  [QCQP_SOLVER_R]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [QCQP_SOLVER_A]
    lba    -- dense, (nc x 1) [QCQP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [QCQP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [QCQP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [QCQP_SOLVER_UBX]
    x0     -- dense, (n x 1) [QCQP_SOLVER_X0]
    lam_x0 -- dense [QCQP_SOLVER_LAM_X0]
  """
  for k in kwargs.keys():
    if k not in ['h', 'g', 'p', 'q', 'r', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0']:
      raise Exception("Error in 'qcqpIn' arguments. You supplied key '%s'. Allowed keys are: 'h', 'g', 'p', 'q', 'r', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'" % k)
  return (kwargs, ['h', 'g', 'p', 'q', 'r', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qcqpIn) qcqpIn<casadi::SX>;
%template(qcqpIn) qcqpIn<casadi::MX>;
%template(qcqpIn) qcqpIn<casadi::Matrix<double> >;
%template(qcqpIn) qcqpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qcqpOut(**kwargs):
  """
  Helper function for 'QcqpSolverOutput'

  Usage:
    arg = qcqpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an QP Solver
  
  Keyword arguments::

    x     -- The primal solution [QCQP_SOLVER_X]
    cost  -- The optimal cost [QCQP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [QCQP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [QCQP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'qcqpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qcqpOut) qcqpOut<casadi::SX>;
%template(qcqpOut) qcqpOut<casadi::MX>;
%template(qcqpOut) qcqpOut<casadi::Matrix<double> >;
%template(qcqpOut) qcqpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpIn(**kwargs):
  """
  Helper function for 'QpSolverInput'

  Usage:
    arg = qpIn(h=my_h, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0)
        all arguments optional
  Input arguments of a QP problem
  
  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [QP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [QP_SOLVER_G]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [QP_SOLVER_A]
    lba    -- dense, (nc x 1) [QP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [QP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [QP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [QP_SOLVER_UBX]
    x0     -- dense, (n x 1) [QP_SOLVER_X0]
    lam_x0 -- dense [QP_SOLVER_LAM_X0]
  """
  for k in kwargs.keys():
    if k not in ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0']:
      raise Exception("Error in 'qpIn' arguments. You supplied key '%s'. Allowed keys are: 'h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'" % k)
  return (kwargs, ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qpIn) qpIn<casadi::SX>;
%template(qpIn) qpIn<casadi::MX>;
%template(qpIn) qpIn<casadi::Matrix<double> >;
%template(qpIn) qpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpOut(**kwargs):
  """
  Helper function for 'QpSolverOutput'

  Usage:
    arg = qpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an QP Solver
  
  Keyword arguments::

    x     -- The primal solution [QP_SOLVER_X]
    cost  -- The optimal cost [QP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [QP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [QP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'qpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qpOut) qpOut<casadi::SX>;
%template(qpOut) qpOut<casadi::MX>;
%template(qpOut) qpOut<casadi::Matrix<double> >;
%template(qpOut) qpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def sdpIn(**kwargs):
  """
  Helper function for 'SDPInput'

  Usage:
    arg = sdpIn(f=my_f, c=my_c, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
        all arguments optional
  Input arguments of a SDP problem
  
  Keyword arguments::

    f   -- The horizontal stack of all matrices F_i: ( m x nm) [SDP_SOLVER_F]
    c   -- The vector c: ( n x 1) [SDP_SOLVER_C]
    g   -- The matrix G: ( m x m) [SDP_SOLVER_G]
    a   -- The matrix A: ( nc x n) [SDP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SDP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SDP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SDP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SDP_SOLVER_UBX]
  """
  for k in kwargs.keys():
    if k not in ['f', 'c', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx']:
      raise Exception("Error in 'sdpIn' arguments. You supplied key '%s'. Allowed keys are: 'f', 'c', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx'" % k)
  return (kwargs, ['f', 'c', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(sdpIn) sdpIn<casadi::SX>;
%template(sdpIn) sdpIn<casadi::MX>;
%template(sdpIn) sdpIn<casadi::Matrix<double> >;
%template(sdpIn) sdpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def sdpOut(**kwargs):
  """
  Helper function for 'SDPOutput'

  Usage:
    arg = sdpOut(x=my_x, p=my_p, dual=my_dual, cost=my_cost, dual_cost=my_dual_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an SDP Solver
  
  Keyword arguments::

    x         -- The primal solution (n x 1) - may be used as initial guess [SDP_SOLVER_X]
    p         -- The solution P (m x m) - may be used as initial guess [SDP_SOLVER_P]
    dual      -- The dual solution (m x m) - may be used as initial guess [SDP_SOLVER_DUAL]
    cost      -- The primal optimal cost (1 x 1) [SDP_SOLVER_COST]
    dual_cost -- The dual optimal cost (1 x 1) [SDP_SOLVER_DUAL_COST]
    lam_a     -- The dual solution corresponding to the linear constraints  (nc x 1) [SDP_SOLVER_LAM_A]
    lam_x     -- The dual solution corresponding to simple bounds  (n x 1) [SDP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'sdpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(sdpOut) sdpOut<casadi::SX>;
%template(sdpOut) sdpOut<casadi::MX>;
%template(sdpOut) sdpOut<casadi::Matrix<double> >;
%template(sdpOut) sdpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def sdqpIn(**kwargs):
  """
  Helper function for 'SDQPInput'

  Usage:
    arg = sdqpIn(h=my_h, c=my_c, f=my_f, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
        all arguments optional
  Input arguments of a SDQP problem
  
  Keyword arguments::

    h   -- The matrix H: sparse ( n x n) [SDQP_SOLVER_H]
    c   -- The vector c: ( n x 1) [SDQP_SOLVER_C]
    f   -- The horizontal stack of all matrices F_i: ( m x nm) [SDQP_SOLVER_F]
    g   -- The matrix G: ( m x m) [SDQP_SOLVER_G]
    a   -- The matrix A: ( nc x n) [SDQP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SDQP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SDQP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SDQP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SDQP_SOLVER_UBX]
  """
  for k in kwargs.keys():
    if k not in ['h', 'c', 'f', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx']:
      raise Exception("Error in 'sdqpIn' arguments. You supplied key '%s'. Allowed keys are: 'h', 'c', 'f', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx'" % k)
  return (kwargs, ['h', 'c', 'f', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(sdqpIn) sdqpIn<casadi::SX>;
%template(sdqpIn) sdqpIn<casadi::MX>;
%template(sdqpIn) sdqpIn<casadi::Matrix<double> >;
%template(sdqpIn) sdqpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def sdqpOut(**kwargs):
  """
  Helper function for 'SDQPOutput'

  Usage:
    arg = sdqpOut(x=my_x, p=my_p, dual=my_dual, cost=my_cost, dual_cost=my_dual_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an SDQP Solver
  
  Keyword arguments::

    x         -- The primal solution (n x 1) - may be used as initial guess [SDQP_SOLVER_X]
    p         -- The solution P (m x m) - may be used as initial guess [SDQP_SOLVER_P]
    dual      -- The dual solution (m x m) - may be used as initial guess [SDQP_SOLVER_DUAL]
    cost      -- The primal optimal cost (1 x 1) [SDQP_SOLVER_COST]
    dual_cost -- The dual optimal cost (1 x 1) [SDQP_SOLVER_DUAL_COST]
    lam_a     -- The dual solution corresponding to the linear constraints  (nc x 1) [SDQP_SOLVER_LAM_A]
    lam_x     -- The dual solution corresponding to simple bounds  (n x 1) [SDQP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'sdqpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'p', 'dual', 'cost', 'dual_cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(sdqpOut) sdqpOut<casadi::SX>;
%template(sdqpOut) sdqpOut<casadi::MX>;
%template(sdqpOut) sdqpOut<casadi::Matrix<double> >;
%template(sdqpOut) sdqpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def socpIn(**kwargs):
  """
  Helper function for 'SOCPInput'

  Usage:
    arg = socpIn(g=my_g, h=my_h, e=my_e, f=my_f, c=my_c, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx)
        all arguments optional
  Input arguments of a SOCP problem
  
  Keyword arguments::

    g   -- The horizontal stack of all matrices Gi: ( n x N) [SOCP_SOLVER_G]
    h   -- The vertical stack of all vectors hi: ( N x 1) [SOCP_SOLVER_H]
    e   -- The horizontal stack of all vectors ei: ( n x m) [SOCP_SOLVER_E]
    f   -- The vertical stack of all scalars fi: ( m x 1) [SOCP_SOLVER_F]
    c   -- The vector c: ( n x 1) [SOCP_SOLVER_C]
    a   -- The matrix A: ( nc x n) [SOCP_SOLVER_A]
    lba -- Lower bounds on Ax ( nc x 1) [SOCP_SOLVER_LBA]
    uba -- Upper bounds on Ax  ( nc x 1) [SOCP_SOLVER_UBA]
    lbx -- Lower bounds on x ( n x 1 ) [SOCP_SOLVER_LBX]
    ubx -- Upper bounds on x ( n x 1 ) [SOCP_SOLVER_UBX]
  """
  for k in kwargs.keys():
    if k not in ['g', 'h', 'e', 'f', 'c', 'a', 'lba', 'uba', 'lbx', 'ubx']:
      raise Exception("Error in 'socpIn' arguments. You supplied key '%s'. Allowed keys are: 'g', 'h', 'e', 'f', 'c', 'a', 'lba', 'uba', 'lbx', 'ubx'" % k)
  return (kwargs, ['g', 'h', 'e', 'f', 'c', 'a', 'lba', 'uba', 'lbx', 'ubx'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(socpIn) socpIn<casadi::SX>;
%template(socpIn) socpIn<casadi::MX>;
%template(socpIn) socpIn<casadi::Matrix<double> >;
%template(socpIn) socpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def socpOut(**kwargs):
  """
  Helper function for 'SOCPOutput'

  Usage:
    arg = socpOut(x=my_x, cost=my_cost, dual_cost=my_dual_cost, lam_a=my_lam_a, lam_x=my_lam_x, lam_cone=my_lam_cone)
        all arguments optional
  Output arguments of an SOCP Solver
  
  Keyword arguments::

    x         -- The primal solution (n x 1) [SOCP_SOLVER_X]
    cost      -- The primal optimal cost (1 x 1) [SOCP_SOLVER_COST]
    dual_cost -- The dual optimal cost (1 x 1) [SOCP_SOLVER_DUAL_COST]
    lam_a     -- The dual solution corresponding to the linear constraints  (nc x 1) [SOCP_SOLVER_LAM_A]
    lam_x     -- The dual solution corresponding to simple bounds  (n x 1) [SOCP_SOLVER_LAM_X]
    lam_cone  -- The dual solution correspoding to cone (2-norm) constraints (m x 1) [SOCP_SOLVER_LAM_CONE]
  """
  for k in kwargs.keys():
    if k not in ['x', 'cost', 'dual_cost', 'lam_a', 'lam_x', 'lam_cone']:
      raise Exception("Error in 'socpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'cost', 'dual_cost', 'lam_a', 'lam_x', 'lam_cone'" % k)
  return (kwargs, ['x', 'cost', 'dual_cost', 'lam_a', 'lam_x', 'lam_cone'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(socpOut) socpOut<casadi::SX>;
%template(socpOut) socpOut<casadi::MX>;
%template(socpOut) socpOut<casadi::Matrix<double> >;
%template(socpOut) socpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def socpStruct(**kwargs):
  """
  Helper function for 'SOCPStruct'

  Usage:
    arg = socpStruct(g=my_g, e=my_e, a=my_a)
        all arguments optional
  Structure specification of an SOCP
  
  Keyword arguments::

    g -- The horizontal stack of all matrices Gi: ( n x N) [SOCP_STRUCT_G]
    e -- The horizontal stack of all vectors ei: ( n x m) [SOCP_STRUCT_E]
    a -- The matrix A: ( nc x n) [SOCP_STRUCT_A]
  """
  for k in kwargs.keys():
    if k not in ['g', 'e', 'a']:
      raise Exception("Error in 'socpStruct' arguments. You supplied key '%s'. Allowed keys are: 'g', 'e', 'a'" % k)
  return (kwargs, ['g', 'e', 'a'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(socpStruct) socpStruct<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def stabilizedQpIn(**kwargs):
  """
  Helper function for 'StabilizedQpSolverInput'

  Usage:
    arg = stabilizedQpIn(h=my_h, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0, muR=my_muR, muE=my_muE, mu=my_mu)
        all arguments optional
  Input arguments of a QP problem
  
  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [STABILIZED_QP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [STABILIZED_QP_SOLVER_G]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [STABILIZED_QP_SOLVER_A]
    lba    -- dense, (nc x 1) [STABILIZED_QP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [STABILIZED_QP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [STABILIZED_QP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [STABILIZED_QP_SOLVER_UBX]
    x0     -- dense, (n x 1) [STABILIZED_QP_SOLVER_X0]
    lam_x0 -- dense [STABILIZED_QP_SOLVER_LAM_X0]
    muR    -- dense (1 x 1) [STABILIZED_QP_SOLVER_MUR]
    muE    -- dense (nc x 1) [STABILIZED_QP_SOLVER_MUE]
    mu     -- dense (nc x 1) [STABILIZED_QP_SOLVER_MU]
  """
  for k in kwargs.keys():
    if k not in ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0', 'muR', 'muE', 'mu']:
      raise Exception("Error in 'stabilizedQpIn' arguments. You supplied key '%s'. Allowed keys are: 'h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0', 'muR', 'muE', 'mu'" % k)
  return (kwargs, ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0', 'muR', 'muE', 'mu'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(stabilizedQpIn) stabilizedQpIn<casadi::SX>;
%template(stabilizedQpIn) stabilizedQpIn<casadi::MX>;
%template(stabilizedQpIn) stabilizedQpIn<casadi::Matrix<double> >;
%template(stabilizedQpIn) stabilizedQpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#endif //AUTOGENERATED_I

