/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010 by Joel Andersson, Moritz Diehl, K.U.Leuven. All rights reserved.
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
%include "casadi/autogenerated.hpp"
#ifdef SWIGPYTHON
%pythoncode %{
def mayerIn(x=[],p=[]):
  """
  Helper function for 'MayerInput'

  Input arguments of a Mayer Term
  nx: Number of states: from ffcn.input(INTEGRATOR_X0).size()
  np: Number of parameters: from option number_of_parameters
  
  Keyword arguments:
    x -- States at the end of integration (nx x 1) [MAYER_X]
    p -- Problem parameters (np x 1) [MAYER_P]
  """
  return [x,p]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(mayerIn_SX) mayerIn<SXMatrix>;
%template(mayerIn_MX) mayerIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def ocpIn(t=[],lbx=[],ubx=[],x_init=[],lbxp=[],ubxp=[],xp_init=[],lbu=[],ubu=[],u_init=[],lbp=[],ubp=[],p_init=[],lbh=[],ubh=[],lbg=[],ubg=[]):
  """
  Helper function for 'OCPInput'

  Input arguments of an OCP Solver
  ns: Number of shooting nodes: from option number_of_grid_points
  nx: Number of states: from ffcn.input(INTEGRATOR_X0).size()
  nc: Number of constants duting intergation: ffcn.input(INTEGRATOR_P).size()
  nu: Number of controls: from nc - np
  np: Number of parameters: from option number_of_parameters
  nh: Number of point constraints: from cfcn.input(0).size()
  
  Keyword arguments:
    t       -- Time grid: ((ns+1) x 1) - default: linspace(0,t_final,ns+1) [OCP_T]
    lbx     -- States lower bounds (nx x (ns+1)) [OCP_LBX]
    ubx     -- States upper bounds (nx x (ns+1)) [OCP_UBX]
    x_init  -- States initial guess (nx x (ns+1)) [OCP_X_INIT]
    lbxp    -- States deriatives lower bounds (nx x (ns+1)) [OCP_LBXP]
    ubxp    -- States deriatives upper bounds (nx x (ns+1)) [OCP_UBXP]
    xp_init -- States deriatives initial guess (nx x (ns+1)) [OCP_XP_INIT]
    lbu     -- Controls lower bounds (nu x ns) [OCP_LBU]
    ubu     -- Controls upper bounds (nu x ns) [OCP_UBU]
    u_init  -- Controls initial guess (nu x ns) [OCP_U_INIT]
    lbp     -- Parameters lower bounds (np x 1) [OCP_LBP]
    ubp     -- Parameters upper bounds (np x 1) [OCP_UBP]
    p_init  -- Parameters initial guess (np x 1) [OCP_P_INIT]
    lbh     -- Point constraint lower bound (nh x (ns+1)) [OCP_LBH]
    ubh     -- Point constraint upper bound (nh x (ns+1)) [OCP_UBH]
    lbg     -- Lower bound for the coupling constraints [OCP_LBG]
    ubg     -- Upper bound for the coupling constraints [OCP_UBG]
  """
  return [t,lbx,ubx,x_init,lbxp,ubxp,xp_init,lbu,ubu,u_init,lbp,ubp,p_init,lbh,ubh,lbg,ubg]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(ocpIn_SX) ocpIn<SXMatrix>;
%template(ocpIn_MX) ocpIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def ocpOut(x_opt=[],u_opt=[],xp_opt=[],p_opt=[]):
  """
  Helper function for 'OCPOutput'

  Output arguments of an OCP Solver
  
  Keyword arguments:
    x_opt  -- Optimal state trajectory [OCP_X_OPT]
    u_opt  -- Optimal control trajectory [OCP_U_OPT]
    xp_opt -- Optimal state derivative trajectory [OCP_XP_OPT]
    p_opt  -- Optimal parameters [OCP_P_OPT]
  """
  return [x_opt,u_opt,xp_opt,p_opt]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(ocpOut_SX) ocpOut<SXMatrix>;
%template(ocpOut_MX) ocpOut<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpIn(h=[],g=[],a=[],lba=[],uba=[],lbx=[],ubx=[],x_init=[],lambda_init=[]):
  """
  Helper function for 'QPInput'

  Input arguments of a QP problem
  
  Keyword arguments:
    h           -- The square matrix H: sparse, (nx x nx). Only the lower triangular part is actually used. The matrix is assumed to be symmetrical. [QP_H]
    g           -- The column vector G: dense,  (nx x 1) [QP_G]
    a           -- The matrix A: sparse, (nc x nx) - product with x must be dense. [QP_A]
    lba         -- dense, (nc x 1) [QP_LBA]
    uba         -- dense, (nc x 1) [QP_UBA]
    lbx         -- dense, (nx x 1) [QP_LBX]
    ubx         -- dense, (nx x 1) [QP_UBX]
    x_init      -- dense, (nx x 1) [QP_X_INIT]
    lambda_init -- dense [QP_LAMBDA_INIT]
  """
  return [h,g,a,lba,uba,lbx,ubx,x_init,lambda_init]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(qpIn_SX) qpIn<SXMatrix>;
%template(qpIn_MX) qpIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpOut(primal=[],cost=[],lambda_a=[],lambda_x=[]):
  """
  Helper function for 'QPOutput'

  Output arguments of an QP Solver
  
  Keyword arguments:
    primal   -- The primal solution [QP_PRIMAL]
    cost     -- The optimal cost [QP_COST]
    lambda_a -- The dual solution corresponding to linear bounds [QP_LAMBDA_A]
    lambda_x -- The dual solution corresponding to simple bounds [QP_LAMBDA_X]
  """
  return [primal,cost,lambda_a,lambda_x]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(qpOut_SX) qpOut<SXMatrix>;
%template(qpOut_MX) qpOut<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def controldaeIn(t=[],x=[],z=[],p=[],u=[],u_interp=[],xdot=[],x_major=[],t0=[],tf=[]):
  """
  Helper function for 'ControlledDAEInput'

  Input arguments of an ODE/DAE function
  
  Keyword arguments:
    t        -- Global physical time. (1-by-1) [CONTROL_DAE_T]
    x        -- State vector (dimension nx-by-1). Should have same amount of non-zeros as DAEOutput:DAE_RES [CONTROL_DAE_X]
    z        -- Algebraic state vector (dimension np-by-1). [CONTROL_DAE_Z]
    p        -- Parameter vector (dimension np-by-1). [CONTROL_DAE_P]
    u        -- Control vector (dimension nu-by-1). [CONTROL_DAE_U]
    u_interp -- Control vector, linearly interpolated (dimension nu-by-1). [CONTROL_DAE_U_INTERP]
    xdot     -- State derivative vector (dimension nx-by-1). Should have same amount of non-zeros as DAEOutput:DAE_RES [CONTROL_DAE_XDOT]
    x_major  -- State vector (dimension nx-by-1) at the last major time-step [CONTROL_DAE_X_MAJOR]
    t0       -- Time at start of control interval (1-by-1) [CONTROL_DAE_T0]
    tf       -- Time at end of control interval (1-by-1) [CONTROL_DAE_TF]
  """
  return [t,x,z,p,u,u_interp,xdot,x_major,t0,tf]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(controldaeIn_SX) controldaeIn<SXMatrix>;
%template(controldaeIn_MX) controldaeIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def controlsimulatorIn(x0=[],p=[],u=[]):
  """
  Helper function for 'ControlSimulatorInput'

  Input arguments of a control simulator
  
  Keyword arguments:
    x0 -- Differential or algebraic state at t0  (dimension nx-by-1) [CONTROLSIMULATOR_X0]
    p  -- Parameters that are fixed over the entire horizon  (dimension np-by-1) [CONTROLSIMULATOR_P]
    u  -- Parameters that change over the integration intervals (dimension (ns-1)-by-nu) [CONTROLSIMULATOR_U]
  """
  return [x0,p,u]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(controlsimulatorIn_SX) controlsimulatorIn<SXMatrix>;
%template(controlsimulatorIn_MX) controlsimulatorIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpsolverIn(x_init=[],lbx=[],ubx=[],lbg=[],ubg=[],lambda_init=[],p=[]):
  """
  Helper function for 'NLPInput'

  Input arguments of an NLP Solver
  
  Keyword arguments:
    x_init      -- Decision variables initial guess (n x 1)  [NLP_X_INIT]
    lbx         -- Decision variables lower bound (n x 1), default -inf [NLP_LBX]
    ubx         -- Decision variables upper bound (n x 1), default +inf [NLP_UBX]
    lbg         -- Constraints lower bound (m x 1), default -inf [NLP_LBG]
    ubg         -- Constraints upper bound (m x 1), default +inf [NLP_UBG]
    lambda_init -- Lagrange multipliers associated with G, initial guess (m x 1) [NLP_LAMBDA_INIT]
    p           -- Only for parametric NLP - static parameters on which the objective and constraints might depend [NLP_P]
  """
  return [x_init,lbx,ubx,lbg,ubg,lambda_init,p]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(nlpsolverIn_SX) nlpsolverIn<SXMatrix>;
%template(nlpsolverIn_MX) nlpsolverIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpsolverOut(x_opt=[],cost=[],lambda_g=[],lambda_x=[],g=[]):
  """
  Helper function for 'NLPOutput'

  Output arguments of an NLP Solver
  
  Keyword arguments:
    x_opt    -- Decision variables for optimal solution (n x 1) [NLP_X_OPT]
    cost     -- Objective/cost function for optimal solution (1 x 1) [NLP_COST]
    lambda_g -- Lagrange multipliers associated with G at the solution (m x 1) [NLP_LAMBDA_G]
    lambda_x -- Lagrange multipliers associated with bounds on X at the solution (n x 1) [NLP_LAMBDA_X]
    g        -- The constraints evaluated at the optimal solution (m x 1) [NLP_G]
  """
  return [x_opt,cost,lambda_g,lambda_x,g]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(nlpsolverOut_SX) nlpsolverOut<SXMatrix>;
%template(nlpsolverOut_MX) nlpsolverOut<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeIn(x=[],z=[],p=[],t=[],xdot=[]):
  """
  Helper function for 'DAEInput'

  Input arguments of an ODE/DAE function
  
  Keyword arguments:
    x    -- Differential state [DAE_X]
    z    -- Algebraic state [DAE_Z]
    p    -- Parameter [DAE_P]
    t    -- Explicit time dependence [DAE_T]
    xdot -- Time derivative of differential states [DAE_XDOT]
  """
  return [x,z,p,t,xdot]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(daeIn_SX) daeIn<SXMatrix>;
%template(daeIn_MX) daeIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeOut(ode=[],alg=[],quad=[]):
  """
  Helper function for 'DAEOutput'

  Output arguments of an DAE function
  
  Keyword arguments:
    ode  -- Right hand side of the implicit ODE [DAE_ODE]
    alg  -- Right hand side of algebraic equations [DAE_ALG]
    quad -- Right hand side of quadratures equations [DAE_QUAD]
  """
  return [ode,alg,quad]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(daeOut_SX) daeOut<SXMatrix>;
%template(daeOut_MX) daeOut<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeIn(rx=[],rz=[],rp=[],x=[],z=[],p=[],t=[],rxdot=[]):
  """
  Helper function for 'RDAEInput'

  Input arguments of an ODE/DAE backward integration function
  
  Keyword arguments:
    rx    -- Backward differential state [RDAE_RX]
    rz    -- Backward algebraic state [RDAE_RZ]
    rp    -- Backward parameter [RDAE_RP]
    x     -- Forward differential state [RDAE_X]
    z     -- Forward algebraic state [RDAE_Z]
    p     -- Parameter vector [RDAE_P]
    t     -- Explicit time dependence [RDAE_T]
    rxdot -- Time derivative of backward differential state [RDAE_RXDOT]
  """
  return [rx,rz,rp,x,z,p,t,rxdot]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(rdaeIn_SX) rdaeIn<SXMatrix>;
%template(rdaeIn_MX) rdaeIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeOut(ode=[],alg=[],quad=[]):
  """
  Helper function for 'RDAEOutput'

  Output arguments of an ODE/DAE backward integration function
  
  Keyword arguments:
    ode  -- Right hand side of ODE. [RDAE_ODE]
    alg  -- Right hand side of algebraic equations. [RDAE_ALG]
    quad -- Right hand side of quadratures. [RDAE_QUAD]
  """
  return [ode,alg,quad]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(rdaeOut_SX) rdaeOut<SXMatrix>;
%template(rdaeOut_MX) rdaeOut<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorIn(x0=[],p=[],rx0=[]):
  """
  Helper function for 'IntegratorInput'

  Input arguments of an integrator
  
  Keyword arguments:
    x0  -- Differential state at the initial time [INTEGRATOR_X0]
    p   -- Parameters [INTEGRATOR_P]
    rx0 -- Backward differential state at the final time [INTEGRATOR_RX0]
  """
  return [x0,p,rx0]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(integratorIn_SX) integratorIn<SXMatrix>;
%template(integratorIn_MX) integratorIn<MX>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorOut(xf=[],qf=[],rxf=[],rqf=[]):
  """
  Helper function for 'IntegratorOutput'

  Output arguments of an integrator
  
  Keyword arguments:
    xf  -- Differential state at the final time [INTEGRATOR_XF]
    qf  -- Quadrature state at the final time [INTEGRATOR_QF]
    rxf -- Backward differential state at the initial time [INTEGRATOR_RXF]
    rqf -- Backward quadrature state at the initial time [INTEGRATOR_RQF]
  """
  return [xf,qf,rxf,rqf]
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace CasADi {
%template(integratorOut_SX) integratorOut<SXMatrix>;
%template(integratorOut_MX) integratorOut<MX>;
}
#endif //SWIGPYTHON
