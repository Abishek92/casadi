/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef AUTOGENERATED_I
#define AUTOGENERATED_I
%include "casadi/core/function/schemes_metadata.hpp"
%include "casadi/core/function/schemes_helpers.hpp"
#ifdef SWIGPYTHON
%pythoncode %{
def daeIn(**kwargs):
  """
  Helper function for 'DAEInput'

  Usage:
    arg = daeIn(x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE function
  
  Keyword arguments::

    x -- Differential state [DAE_X]
    z -- Algebraic state [DAE_Z]
    p -- Parameter [DAE_P]
    t -- Explicit time dependence [DAE_T]
  """
  for k in kwargs.keys():
    if k not in ['x', 'z', 'p', 't']:
      raise Exception("Error in 'daeIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeIn) daeIn<casadi::SX>;
%template(daeIn) daeIn<casadi::MX>;
%template(daeIn) daeIn<casadi::Matrix<double> >;
%template(daeIn) daeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeOut(**kwargs):
  """
  Helper function for 'DAEOutput'

  Usage:
    arg = daeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an DAE function
  
  Keyword arguments::

    ode  -- Right hand side of the implicit ODE [DAE_ODE]
    alg  -- Right hand side of algebraic equations [DAE_ALG]
    quad -- Right hand side of quadratures equations [DAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'daeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeOut) daeOut<casadi::SX>;
%template(daeOut) daeOut<casadi::MX>;
%template(daeOut) daeOut<casadi::Matrix<double> >;
%template(daeOut) daeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeIn(**kwargs):
  """
  Helper function for 'RDAEInput'

  Usage:
    arg = rdaeIn(rx=my_rx, rz=my_rz, rp=my_rp, x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    rx -- Backward differential state [RDAE_RX]
    rz -- Backward algebraic state [RDAE_RZ]
    rp -- Backward  parameter vector [RDAE_RP]
    x  -- Forward differential state [RDAE_X]
    z  -- Forward algebraic state [RDAE_Z]
    p  -- Parameter vector [RDAE_P]
    t  -- Explicit time dependence [RDAE_T]
  """
  for k in kwargs.keys():
    if k not in ['rx', 'rz', 'rp', 'x', 'z', 'p', 't']:
      raise Exception("Error in 'rdaeIn' arguments. You supplied key '%s'. Allowed keys are: 'rx', 'rz', 'rp', 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['rx', 'rz', 'rp', 'x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeIn) rdaeIn<casadi::SX>;
%template(rdaeIn) rdaeIn<casadi::MX>;
%template(rdaeIn) rdaeIn<casadi::Matrix<double> >;
%template(rdaeIn) rdaeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeOut(**kwargs):
  """
  Helper function for 'RDAEOutput'

  Usage:
    arg = rdaeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    ode  -- Right hand side of ODE. [RDAE_ODE]
    alg  -- Right hand side of algebraic equations. [RDAE_ALG]
    quad -- Right hand side of quadratures. [RDAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'rdaeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeOut) rdaeOut<casadi::SX>;
%template(rdaeOut) rdaeOut<casadi::MX>;
%template(rdaeOut) rdaeOut<casadi::Matrix<double> >;
%template(rdaeOut) rdaeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorIn(**kwargs):
  """
  Helper function for 'IntegratorInput'

  Usage:
    arg = integratorIn(x0=my_x0, p=my_p, z0=my_z0, rx0=my_rx0, rp=my_rp, rz0=my_rz0)
        all arguments optional
  Input arguments of an integrator
  
  Keyword arguments::

    x0  -- Differential state at the initial time [INTEGRATOR_X0]
    p   -- Parameters [INTEGRATOR_P]
    z0  -- Initial guess for the algebraic variable [INTEGRATOR_Z0]
    rx0 -- Backward differential state at the final time [INTEGRATOR_RX0]
    rp  -- Backward parameter vector [INTEGRATOR_RP]
    rz0 -- Initial guess for the backwards algebraic variable [INTEGRATOR_RZ0]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0']:
      raise Exception("Error in 'integratorIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'z0', 'rx0', 'rp', 'rz0'" % k)
  return (kwargs, ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorIn) integratorIn<casadi::SX>;
%template(integratorIn) integratorIn<casadi::MX>;
%template(integratorIn) integratorIn<casadi::Matrix<double> >;
%template(integratorIn) integratorIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorOut(**kwargs):
  """
  Helper function for 'IntegratorOutput'

  Usage:
    arg = integratorOut(xf=my_xf, qf=my_qf, zf=my_zf, rxf=my_rxf, rqf=my_rqf, rzf=my_rzf)
        all arguments optional
  Output arguments of an integrator
  
  Keyword arguments::

    xf  -- Differential state at the final time [INTEGRATOR_XF]
    qf  -- Quadrature state at the final time [INTEGRATOR_QF]
    zf  -- Algebraic variable at the final time [INTEGRATOR_ZF]
    rxf -- Backward differential state at the initial time [INTEGRATOR_RXF]
    rqf -- Backward quadrature state at the initial time [INTEGRATOR_RQF]
    rzf -- Backward algebraic variable at the initial time [INTEGRATOR_RZF]
  """
  for k in kwargs.keys():
    if k not in ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf']:
      raise Exception("Error in 'integratorOut' arguments. You supplied key '%s'. Allowed keys are: 'xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'" % k)
  return (kwargs, ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorOut) integratorOut<casadi::SX>;
%template(integratorOut) integratorOut<casadi::MX>;
%template(integratorOut) integratorOut<casadi::Matrix<double> >;
%template(integratorOut) integratorOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpIn(**kwargs):
  """
  Helper function for 'NLPInput'

  Usage:
    arg = nlpIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP function
  
  Keyword arguments::

    x -- Decision variable [NL_X]
    p -- Fixed parameter [NL_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'nlpIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpIn) nlpIn<casadi::SX>;
%template(nlpIn) nlpIn<casadi::MX>;
%template(nlpIn) nlpIn<casadi::Matrix<double> >;
%template(nlpIn) nlpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpOut(**kwargs):
  """
  Helper function for 'NLPOutput'

  Usage:
    arg = nlpOut(f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP function
  
  Keyword arguments::

    f -- Objective function [NL_F]
    g -- Constraint function [NL_G]
  """
  for k in kwargs.keys():
    if k not in ['f', 'g']:
      raise Exception("Error in 'nlpOut' arguments. You supplied key '%s'. Allowed keys are: 'f', 'g'" % k)
  return (kwargs, ['f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpOut) nlpOut<casadi::SX>;
%template(nlpOut) nlpOut<casadi::MX>;
%template(nlpOut) nlpOut<casadi::Matrix<double> >;
%template(nlpOut) nlpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFIn(**kwargs):
  """
  Helper function for 'GradFInput'

  Usage:
    arg = gradFIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP objective gradient function
  
  Keyword arguments::

    x -- Decision variable [GRADF_X]
    p -- Fixed parameter [GRADF_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'gradFIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFIn) gradFIn<casadi::SX>;
%template(gradFIn) gradFIn<casadi::MX>;
%template(gradFIn) gradFIn<casadi::Matrix<double> >;
%template(gradFIn) gradFIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFOut(**kwargs):
  """
  Helper function for 'GradFOutput'

  Usage:
    arg = gradFOut(grad=my_grad, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP objective gradient function
  
  Keyword arguments::

    grad -- Jacobian of the constraints [GRADF_GRAD]
    f    -- Objective function [GRADF_F]
    g    -- Constraint function [GRADF_G]
  """
  for k in kwargs.keys():
    if k not in ['grad', 'f', 'g']:
      raise Exception("Error in 'gradFOut' arguments. You supplied key '%s'. Allowed keys are: 'grad', 'f', 'g'" % k)
  return (kwargs, ['grad', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFOut) gradFOut<casadi::SX>;
%template(gradFOut) gradFOut<casadi::MX>;
%template(gradFOut) gradFOut<casadi::Matrix<double> >;
%template(gradFOut) gradFOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGIn(**kwargs):
  """
  Helper function for 'JacGInput'

  Usage:
    arg = jacGIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP Jacobian function
  
  Keyword arguments::

    x -- Decision variable [JACG_X]
    p -- Fixed parameter [JACG_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'jacGIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGIn) jacGIn<casadi::SX>;
%template(jacGIn) jacGIn<casadi::MX>;
%template(jacGIn) jacGIn<casadi::Matrix<double> >;
%template(jacGIn) jacGIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGOut(**kwargs):
  """
  Helper function for 'JacGOutput'

  Usage:
    arg = jacGOut(jac=my_jac, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP Jacobian function
  
  Keyword arguments::

    jac -- Jacobian of the constraints [JACG_JAC]
    f   -- Objective function [JACG_F]
    g   -- Constraint function [JACG_G]
  """
  for k in kwargs.keys():
    if k not in ['jac', 'f', 'g']:
      raise Exception("Error in 'jacGOut' arguments. You supplied key '%s'. Allowed keys are: 'jac', 'f', 'g'" % k)
  return (kwargs, ['jac', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGOut) jacGOut<casadi::SX>;
%template(jacGOut) jacGOut<casadi::MX>;
%template(jacGOut) jacGOut<casadi::Matrix<double> >;
%template(jacGOut) jacGOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hessLagIn(**kwargs):
  """
  Helper function for 'HessLagInput'

  Usage:
    arg = hessLagIn(x=my_x, p=my_p, lam_f=my_lam_f, lam_g=my_lam_g)
        all arguments optional
  Input arguments of an NLP Hessian function
  
  Keyword arguments::

    x     -- Decision variable [HESSLAG_X]
    p     -- Fixed parameter [HESSLAG_P]
    lam_f -- NLP solver might use to scale the objective. [HESSLAG_LAM_F]
    lam_g -- Multiplier for g [HESSLAG_LAM_G]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'lam_f', 'lam_g']:
      raise Exception("Error in 'hessLagIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'lam_f', 'lam_g'" % k)
  return (kwargs, ['x', 'p', 'lam_f', 'lam_g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hessLagIn) hessLagIn<casadi::SX>;
%template(hessLagIn) hessLagIn<casadi::MX>;
%template(hessLagIn) hessLagIn<casadi::Matrix<double> >;
%template(hessLagIn) hessLagIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hessLagOut(**kwargs):
  """
  Helper function for 'HessLagOutput'

  Usage:
    arg = hessLagOut(hess=my_hess, f=my_f, g=my_g, grad_x=my_grad_x, grad_p=my_grad_p)
        all arguments optional
  Output arguments of an NLP Hessian function
  
  Keyword arguments::

    hess   -- Hessian of the Lagrangian [HESSLAG_HESS]
    f      -- Objective function [HESSLAG_F]
    g      -- Constraint function [HESSLAG_G]
    grad_x -- Gradient of the Lagrangian with respect to x [HESSLAG_GRAD_X]
    grad_p -- Gradient of the Lagrangian with respect to p [HESSLAG_GRAD_P]
  """
  for k in kwargs.keys():
    if k not in ['hess', 'f', 'g', 'grad_x', 'grad_p']:
      raise Exception("Error in 'hessLagOut' arguments. You supplied key '%s'. Allowed keys are: 'hess', 'f', 'g', 'grad_x', 'grad_p'" % k)
  return (kwargs, ['hess', 'f', 'g', 'grad_x', 'grad_p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hessLagOut) hessLagOut<casadi::SX>;
%template(hessLagOut) hessLagOut<casadi::MX>;
%template(hessLagOut) hessLagOut<casadi::Matrix<double> >;
%template(hessLagOut) hessLagOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpSolverIn(**kwargs):
  """
  Helper function for 'NlpSolverInput'

  Usage:
    arg = nlpSolverIn(x0=my_x0, p=my_p, lbx=my_lbx, ubx=my_ubx, lbg=my_lbg, ubg=my_ubg, lam_x0=my_lam_x0, lam_g0=my_lam_g0)
        all arguments optional
  Input arguments of an NLP Solver
  
  Keyword arguments::

    x0     -- Decision variables, initial guess (nx x 1)  [NLP_SOLVER_X0]
    p      -- Value of fixed parameters (np x 1) [NLP_SOLVER_P]
    lbx    -- Decision variables lower bound (nx x 1), default -inf [NLP_SOLVER_LBX]
    ubx    -- Decision variables upper bound (nx x 1), default +inf [NLP_SOLVER_UBX]
    lbg    -- Constraints lower bound (ng x 1), default -inf [NLP_SOLVER_LBG]
    ubg    -- Constraints upper bound (ng x 1), default +inf [NLP_SOLVER_UBG]
    lam_x0 -- Lagrange multipliers for bounds on X, initial guess (nx x 1) [NLP_SOLVER_LAM_X0]
    lam_g0 -- Lagrange multipliers for bounds on G, initial guess (ng x 1) [NLP_SOLVER_LAM_G0]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0']:
      raise Exception("Error in 'nlpSolverIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0'" % k)
  return (kwargs, ['x0', 'p', 'lbx', 'ubx', 'lbg', 'ubg', 'lam_x0', 'lam_g0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpSolverIn) nlpSolverIn<casadi::SX>;
%template(nlpSolverIn) nlpSolverIn<casadi::MX>;
%template(nlpSolverIn) nlpSolverIn<casadi::Matrix<double> >;
%template(nlpSolverIn) nlpSolverIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpSolverOut(**kwargs):
  """
  Helper function for 'NlpSolverOutput'

  Usage:
    arg = nlpSolverOut(x=my_x, f=my_f, g=my_g, lam_x=my_lam_x, lam_g=my_lam_g, lam_p=my_lam_p)
        all arguments optional
  Output arguments of an NLP Solver
  
  Keyword arguments::

    x     -- Decision variables at the optimal solution (nx x 1) [NLP_SOLVER_X]
    f     -- Cost function value at the optimal solution (1 x 1) [NLP_SOLVER_F]
    g     -- Constraints function at the optimal solution (ng x 1) [NLP_SOLVER_G]
    lam_x -- Lagrange multipliers for bounds on X at the solution (nx x 1) [NLP_SOLVER_LAM_X]
    lam_g -- Lagrange multipliers for bounds on G at the solution (ng x 1) [NLP_SOLVER_LAM_G]
    lam_p -- Lagrange multipliers for bounds on P at the solution (np x 1) [NLP_SOLVER_LAM_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p']:
      raise Exception("Error in 'nlpSolverOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'" % k)
  return (kwargs, ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpSolverOut) nlpSolverOut<casadi::SX>;
%template(nlpSolverOut) nlpSolverOut<casadi::MX>;
%template(nlpSolverOut) nlpSolverOut<casadi::Matrix<double> >;
%template(nlpSolverOut) nlpSolverOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpIn(**kwargs):
  """
  Helper function for 'QpSolverInput'

  Usage:
    arg = qpIn(h=my_h, g=my_g, a=my_a, lba=my_lba, uba=my_uba, lbx=my_lbx, ubx=my_ubx, x0=my_x0, lam_x0=my_lam_x0)
        all arguments optional
  Input arguments of a QP problem
  
  Keyword arguments::

    h      -- The matrix is assumed to be symmetrical. [QP_SOLVER_H]
    g      -- The vector g: dense,  (n x 1) [QP_SOLVER_G]
    a      -- The matrix A: sparse, (nc x n) - product with x must be dense. [QP_SOLVER_A]
    lba    -- dense, (nc x 1) [QP_SOLVER_LBA]
    uba    -- dense, (nc x 1) [QP_SOLVER_UBA]
    lbx    -- dense, (n x 1) [QP_SOLVER_LBX]
    ubx    -- dense, (n x 1) [QP_SOLVER_UBX]
    x0     -- dense, (n x 1) [QP_SOLVER_X0]
    lam_x0 -- dense [QP_SOLVER_LAM_X0]
  """
  for k in kwargs.keys():
    if k not in ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0']:
      raise Exception("Error in 'qpIn' arguments. You supplied key '%s'. Allowed keys are: 'h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'" % k)
  return (kwargs, ['h', 'g', 'a', 'lba', 'uba', 'lbx', 'ubx', 'x0', 'lam_x0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qpIn) qpIn<casadi::SX>;
%template(qpIn) qpIn<casadi::MX>;
%template(qpIn) qpIn<casadi::Matrix<double> >;
%template(qpIn) qpIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def qpOut(**kwargs):
  """
  Helper function for 'QpSolverOutput'

  Usage:
    arg = qpOut(x=my_x, cost=my_cost, lam_a=my_lam_a, lam_x=my_lam_x)
        all arguments optional
  Output arguments of an QP Solver
  
  Keyword arguments::

    x     -- The primal solution [QP_SOLVER_X]
    cost  -- The optimal cost [QP_SOLVER_COST]
    lam_a -- The dual solution corresponding to linear bounds [QP_SOLVER_LAM_A]
    lam_x -- The dual solution corresponding to simple bounds [QP_SOLVER_LAM_X]
  """
  for k in kwargs.keys():
    if k not in ['x', 'cost', 'lam_a', 'lam_x']:
      raise Exception("Error in 'qpOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'cost', 'lam_a', 'lam_x'" % k)
  return (kwargs, ['x', 'cost', 'lam_a', 'lam_x'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(qpOut) qpOut<casadi::SX>;
%template(qpOut) qpOut<casadi::MX>;
%template(qpOut) qpOut<casadi::Matrix<double> >;
%template(qpOut) qpOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolIn(**kwargs):
  """
  Helper function for 'LinsolInput'

  Usage:
    arg = linsolIn(A=my_A, B=my_B)
        all arguments optional
  Input arguments of a linear solver
  
  Keyword arguments::

    A -- The square matrix A: sparse, (n x n). [LINSOL_A]
    B -- The right-hand-side matrix b: dense,  (n x m) [LINSOL_B]
  """
  for k in kwargs.keys():
    if k not in ['A', 'B']:
      raise Exception("Error in 'linsolIn' arguments. You supplied key '%s'. Allowed keys are: 'A', 'B'" % k)
  return (kwargs, ['A', 'B'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolIn) linsolIn<casadi::SX>;
%template(linsolIn) linsolIn<casadi::MX>;
%template(linsolIn) linsolIn<casadi::Matrix<double> >;
%template(linsolIn) linsolIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolOut(**kwargs):
  """
  Helper function for 'LinsolOutput'

  Usage:
    arg = linsolOut(X=my_X)
        all arguments optional
  Output arguments of a linear solver
  
  Keyword arguments::

    X -- Solution to the linear system of equations [LINSOL_X]
  """
  for k in kwargs.keys():
    if k not in ['X']:
      raise Exception("Error in 'linsolOut' arguments. You supplied key '%s'. Allowed keys are: 'X'" % k)
  return (kwargs, ['X'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolOut) linsolOut<casadi::SX>;
%template(linsolOut) linsolOut<casadi::MX>;
%template(linsolOut) linsolOut<casadi::Matrix<double> >;
%template(linsolOut) linsolOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#endif //AUTOGENERATED_I

