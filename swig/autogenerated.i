/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#ifndef AUTOGENERATED_I
#define AUTOGENERATED_I
%include "casadi/core/function/schemes_metadata.hpp"
%include "casadi/core/function/schemes_helpers.hpp"
#ifdef SWIGPYTHON
%pythoncode %{
def daeIn(**kwargs):
  """
  Helper function for 'DAEInput'

  Usage:
    arg = daeIn(x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE function
  
  Keyword arguments::

    x -- Differential state [DAE_X]
    z -- Algebraic state [DAE_Z]
    p -- Parameter [DAE_P]
    t -- Explicit time dependence [DAE_T]
  """
  for k in kwargs.keys():
    if k not in ['x', 'z', 'p', 't']:
      raise Exception("Error in 'daeIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeIn) daeIn<casadi::SX>;
%template(daeIn) daeIn<casadi::MX>;
%template(daeIn) daeIn<casadi::Matrix<double> >;
%template(daeIn) daeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def daeOut(**kwargs):
  """
  Helper function for 'DAEOutput'

  Usage:
    arg = daeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an DAE function
  
  Keyword arguments::

    ode  -- Right hand side of the implicit ODE [DAE_ODE]
    alg  -- Right hand side of algebraic equations [DAE_ALG]
    quad -- Right hand side of quadratures equations [DAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'daeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(daeOut) daeOut<casadi::SX>;
%template(daeOut) daeOut<casadi::MX>;
%template(daeOut) daeOut<casadi::Matrix<double> >;
%template(daeOut) daeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeIn(**kwargs):
  """
  Helper function for 'RDAEInput'

  Usage:
    arg = rdaeIn(rx=my_rx, rz=my_rz, rp=my_rp, x=my_x, z=my_z, p=my_p, t=my_t)
        all arguments optional
  Input arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    rx -- Backward differential state [RDAE_RX]
    rz -- Backward algebraic state [RDAE_RZ]
    rp -- Backward  parameter vector [RDAE_RP]
    x  -- Forward differential state [RDAE_X]
    z  -- Forward algebraic state [RDAE_Z]
    p  -- Parameter vector [RDAE_P]
    t  -- Explicit time dependence [RDAE_T]
  """
  for k in kwargs.keys():
    if k not in ['rx', 'rz', 'rp', 'x', 'z', 'p', 't']:
      raise Exception("Error in 'rdaeIn' arguments. You supplied key '%s'. Allowed keys are: 'rx', 'rz', 'rp', 'x', 'z', 'p', 't'" % k)
  return (kwargs, ['rx', 'rz', 'rp', 'x', 'z', 'p', 't'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeIn) rdaeIn<casadi::SX>;
%template(rdaeIn) rdaeIn<casadi::MX>;
%template(rdaeIn) rdaeIn<casadi::Matrix<double> >;
%template(rdaeIn) rdaeIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def rdaeOut(**kwargs):
  """
  Helper function for 'RDAEOutput'

  Usage:
    arg = rdaeOut(ode=my_ode, alg=my_alg, quad=my_quad)
        all arguments optional
  Output arguments of an ODE/DAE backward integration function
  
  Keyword arguments::

    ode  -- Right hand side of ODE. [RDAE_ODE]
    alg  -- Right hand side of algebraic equations. [RDAE_ALG]
    quad -- Right hand side of quadratures. [RDAE_QUAD]
  """
  for k in kwargs.keys():
    if k not in ['ode', 'alg', 'quad']:
      raise Exception("Error in 'rdaeOut' arguments. You supplied key '%s'. Allowed keys are: 'ode', 'alg', 'quad'" % k)
  return (kwargs, ['ode', 'alg', 'quad'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(rdaeOut) rdaeOut<casadi::SX>;
%template(rdaeOut) rdaeOut<casadi::MX>;
%template(rdaeOut) rdaeOut<casadi::Matrix<double> >;
%template(rdaeOut) rdaeOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorIn(**kwargs):
  """
  Helper function for 'IntegratorInput'

  Usage:
    arg = integratorIn(x0=my_x0, p=my_p, z0=my_z0, rx0=my_rx0, rp=my_rp, rz0=my_rz0)
        all arguments optional
  Input arguments of an integrator
  
  Keyword arguments::

    x0  -- Differential state at the initial time [INTEGRATOR_X0]
    p   -- Parameters [INTEGRATOR_P]
    z0  -- Initial guess for the algebraic variable [INTEGRATOR_Z0]
    rx0 -- Backward differential state at the final time [INTEGRATOR_RX0]
    rp  -- Backward parameter vector [INTEGRATOR_RP]
    rz0 -- Initial guess for the backwards algebraic variable [INTEGRATOR_RZ0]
  """
  for k in kwargs.keys():
    if k not in ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0']:
      raise Exception("Error in 'integratorIn' arguments. You supplied key '%s'. Allowed keys are: 'x0', 'p', 'z0', 'rx0', 'rp', 'rz0'" % k)
  return (kwargs, ['x0', 'p', 'z0', 'rx0', 'rp', 'rz0'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorIn) integratorIn<casadi::SX>;
%template(integratorIn) integratorIn<casadi::MX>;
%template(integratorIn) integratorIn<casadi::Matrix<double> >;
%template(integratorIn) integratorIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def integratorOut(**kwargs):
  """
  Helper function for 'IntegratorOutput'

  Usage:
    arg = integratorOut(xf=my_xf, qf=my_qf, zf=my_zf, rxf=my_rxf, rqf=my_rqf, rzf=my_rzf)
        all arguments optional
  Output arguments of an integrator
  
  Keyword arguments::

    xf  -- Differential state at the final time [INTEGRATOR_XF]
    qf  -- Quadrature state at the final time [INTEGRATOR_QF]
    zf  -- Algebraic variable at the final time [INTEGRATOR_ZF]
    rxf -- Backward differential state at the initial time [INTEGRATOR_RXF]
    rqf -- Backward quadrature state at the initial time [INTEGRATOR_RQF]
    rzf -- Backward algebraic variable at the initial time [INTEGRATOR_RZF]
  """
  for k in kwargs.keys():
    if k not in ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf']:
      raise Exception("Error in 'integratorOut' arguments. You supplied key '%s'. Allowed keys are: 'xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'" % k)
  return (kwargs, ['xf', 'qf', 'zf', 'rxf', 'rqf', 'rzf'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(integratorOut) integratorOut<casadi::SX>;
%template(integratorOut) integratorOut<casadi::MX>;
%template(integratorOut) integratorOut<casadi::Matrix<double> >;
%template(integratorOut) integratorOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFIn(**kwargs):
  """
  Helper function for 'GradFInput'

  Usage:
    arg = gradFIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP objective gradient function
  
  Keyword arguments::

    x -- Decision variable [GRADF_X]
    p -- Fixed parameter [GRADF_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'gradFIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFIn) gradFIn<casadi::SX>;
%template(gradFIn) gradFIn<casadi::MX>;
%template(gradFIn) gradFIn<casadi::Matrix<double> >;
%template(gradFIn) gradFIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def gradFOut(**kwargs):
  """
  Helper function for 'GradFOutput'

  Usage:
    arg = gradFOut(grad=my_grad, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP objective gradient function
  
  Keyword arguments::

    grad -- Jacobian of the constraints [GRADF_GRAD]
    f    -- Objective function [GRADF_F]
    g    -- Constraint function [GRADF_G]
  """
  for k in kwargs.keys():
    if k not in ['grad', 'f', 'g']:
      raise Exception("Error in 'gradFOut' arguments. You supplied key '%s'. Allowed keys are: 'grad', 'f', 'g'" % k)
  return (kwargs, ['grad', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(gradFOut) gradFOut<casadi::SX>;
%template(gradFOut) gradFOut<casadi::MX>;
%template(gradFOut) gradFOut<casadi::Matrix<double> >;
%template(gradFOut) gradFOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGIn(**kwargs):
  """
  Helper function for 'JacGInput'

  Usage:
    arg = jacGIn(x=my_x, p=my_p)
        all arguments optional
  Input arguments of an NLP Jacobian function
  
  Keyword arguments::

    x -- Decision variable [JACG_X]
    p -- Fixed parameter [JACG_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p']:
      raise Exception("Error in 'jacGIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p'" % k)
  return (kwargs, ['x', 'p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGIn) jacGIn<casadi::SX>;
%template(jacGIn) jacGIn<casadi::MX>;
%template(jacGIn) jacGIn<casadi::Matrix<double> >;
%template(jacGIn) jacGIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def jacGOut(**kwargs):
  """
  Helper function for 'JacGOutput'

  Usage:
    arg = jacGOut(jac=my_jac, f=my_f, g=my_g)
        all arguments optional
  Output arguments of an NLP Jacobian function
  
  Keyword arguments::

    jac -- Jacobian of the constraints [JACG_JAC]
    f   -- Objective function [JACG_F]
    g   -- Constraint function [JACG_G]
  """
  for k in kwargs.keys():
    if k not in ['jac', 'f', 'g']:
      raise Exception("Error in 'jacGOut' arguments. You supplied key '%s'. Allowed keys are: 'jac', 'f', 'g'" % k)
  return (kwargs, ['jac', 'f', 'g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(jacGOut) jacGOut<casadi::SX>;
%template(jacGOut) jacGOut<casadi::MX>;
%template(jacGOut) jacGOut<casadi::Matrix<double> >;
%template(jacGOut) jacGOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def hessLagIn(**kwargs):
  """
  Helper function for 'HessLagInput'

  Usage:
    arg = hessLagIn(x=my_x, p=my_p, lam_f=my_lam_f, lam_g=my_lam_g)
        all arguments optional
  Input arguments of an NLP Hessian function
  
  Keyword arguments::

    x     -- Decision variable [HESSLAG_X]
    p     -- Fixed parameter [HESSLAG_P]
    lam_f -- NLP solver might use to scale the objective. [HESSLAG_LAM_F]
    lam_g -- Multiplier for g [HESSLAG_LAM_G]
  """
  for k in kwargs.keys():
    if k not in ['x', 'p', 'lam_f', 'lam_g']:
      raise Exception("Error in 'hessLagIn' arguments. You supplied key '%s'. Allowed keys are: 'x', 'p', 'lam_f', 'lam_g'" % k)
  return (kwargs, ['x', 'p', 'lam_f', 'lam_g'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(hessLagIn) hessLagIn<casadi::SX>;
%template(hessLagIn) hessLagIn<casadi::MX>;
%template(hessLagIn) hessLagIn<casadi::Matrix<double> >;
%template(hessLagIn) hessLagIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def nlpSolverOut(**kwargs):
  """
  Helper function for 'NlpSolverOutput'

  Usage:
    arg = nlpSolverOut(x=my_x, f=my_f, g=my_g, lam_x=my_lam_x, lam_g=my_lam_g, lam_p=my_lam_p)
        all arguments optional
  Output arguments of an NLP Solver
  
  Keyword arguments::

    x     -- Decision variables at the optimal solution (nx x 1) [NLP_SOLVER_X]
    f     -- Cost function value at the optimal solution (1 x 1) [NLP_SOLVER_F]
    g     -- Constraints function at the optimal solution (ng x 1) [NLP_SOLVER_G]
    lam_x -- Lagrange multipliers for bounds on X at the solution (nx x 1) [NLP_SOLVER_LAM_X]
    lam_g -- Lagrange multipliers for bounds on G at the solution (ng x 1) [NLP_SOLVER_LAM_G]
    lam_p -- Lagrange multipliers for bounds on P at the solution (np x 1) [NLP_SOLVER_LAM_P]
  """
  for k in kwargs.keys():
    if k not in ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p']:
      raise Exception("Error in 'nlpSolverOut' arguments. You supplied key '%s'. Allowed keys are: 'x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'" % k)
  return (kwargs, ['x', 'f', 'g', 'lam_x', 'lam_g', 'lam_p'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(nlpSolverOut) nlpSolverOut<casadi::SX>;
%template(nlpSolverOut) nlpSolverOut<casadi::MX>;
%template(nlpSolverOut) nlpSolverOut<casadi::Matrix<double> >;
%template(nlpSolverOut) nlpSolverOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolIn(**kwargs):
  """
  Helper function for 'LinsolInput'

  Usage:
    arg = linsolIn(A=my_A, B=my_B)
        all arguments optional
  Input arguments of a linear solver
  
  Keyword arguments::

    A -- The square matrix A: sparse, (n x n). [LINSOL_A]
    B -- The right-hand-side matrix b: dense,  (n x m) [LINSOL_B]
  """
  for k in kwargs.keys():
    if k not in ['A', 'B']:
      raise Exception("Error in 'linsolIn' arguments. You supplied key '%s'. Allowed keys are: 'A', 'B'" % k)
  return (kwargs, ['A', 'B'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolIn) linsolIn<casadi::SX>;
%template(linsolIn) linsolIn<casadi::MX>;
%template(linsolIn) linsolIn<casadi::Matrix<double> >;
%template(linsolIn) linsolIn<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#ifdef SWIGPYTHON
%pythoncode %{
def linsolOut(**kwargs):
  """
  Helper function for 'LinsolOutput'

  Usage:
    arg = linsolOut(X=my_X)
        all arguments optional
  Output arguments of a linear solver
  
  Keyword arguments::

    X -- Solution to the linear system of equations [LINSOL_X]
  """
  for k in kwargs.keys():
    if k not in ['X']:
      raise Exception("Error in 'linsolOut' arguments. You supplied key '%s'. Allowed keys are: 'X'" % k)
  return (kwargs, ['X'])
%}
#endif //SWIGPYTHON
#ifndef SWIGPYTHON
namespace casadi {
%template(linsolOut) linsolOut<casadi::SX>;
%template(linsolOut) linsolOut<casadi::MX>;
%template(linsolOut) linsolOut<casadi::Matrix<double> >;
%template(linsolOut) linsolOut<casadi::Sparsity>;
}
#endif //SWIGPYTHON
#endif //AUTOGENERATED_I

